{
  "language": "Solidity",
  "sources": {
    "contracts/decentraname/DecentraName.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract DecentraName is ERC721, Ownable {\r\n\r\n    bytes4 constant private INTERFACE_META_ID = 0x01ffc9a7;\r\n    bytes4 constant private ERC721_ID = bytes4(\r\n        keccak256(\"balanceOf(address)\") ^\r\n        keccak256(\"ownerOf(uint256)\") ^\r\n        keccak256(\"approve(address,uint256)\") ^\r\n        keccak256(\"getApproved(uint256)\") ^\r\n        keccak256(\"setApprovalForAll(address,bool)\") ^\r\n        keccak256(\"isApprovedForAll(address,address)\") ^\r\n        keccak256(\"transferFrom(address,address,uint256)\") ^\r\n        keccak256(\"safeTransferFrom(address,address,uint256)\") ^\r\n        keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")\r\n    );\r\n\r\n    // TODO: UI has to call setApprovalForAll(<address of DecentraNameController>, true) on this contract before doing registration/transfer\r\n\r\n    // TODO: update token name and description\r\n    constructor() ERC721(\"DCN\",\"DecentraName\") {\r\n        // TODO: is it ok to mint in constructor\r\n        // setting owner of root(0x0)\r\n        //_safeMint(_rootContract, 0x0);\r\n    }\r\n\r\n    /**\r\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\r\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\r\n     * @dev Returns whether the given spender can transfer a given token ID\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     *    is an operator of the owner, or is the owner of the token\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual override(ERC721) returns (bool) {\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID. Names become unowned\r\n     *      when their registration expires.\r\n     * @param tokenId uint256 ID of the token to query the owner of\r\n     * @return address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override(ERC721) returns (address) {\r\n        return super.ownerOf(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     *    is an operator of the owner, or is the owner of the token\r\n     */\r\n    function isApprovedOrOwner(address spender, uint256 tokenId) public view virtual returns (bool) {\r\n        return _isApprovedOrOwner(spender, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     * @param tokenId uint256 ID of the token\r\n     * @return * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function existsToken(uint256 tokenId) public view virtual returns (bool) {\r\n        return _exists(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * @param tokenId uint256 ID of the token\r\n     */\r\n    function burnToken(uint256 tokenId) public virtual onlyOwner {\r\n        _burn(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `tokenId` and transfers it to `to`.\r\n     * @param owner owner of the token to be set after mint\r\n     * @param id uint256 ID of the token\r\n     */\r\n    function mintToken(address owner, uint256 id) public virtual onlyOwner {\r\n        _safeMint(owner, id);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` to `to`.\r\n     * @param to transfer token to this address\r\n     * @param id uint256 ID of the token\r\n     */\r\n    function transferToken(address to, uint256 id) public virtual onlyOwner{\r\n        address from = super.ownerOf(id);\r\n        safeTransferFrom(from, to, id);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public override(ERC721) view returns (bool) {\r\n        return interfaceID == INTERFACE_META_ID ||\r\n               interfaceID == ERC721_ID;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/decentraname/DecentraNameController.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nimport \"./DecentraName.sol\";\r\nimport \"../root/Controllable.sol\";\r\nimport \"./IDecentraNameController.sol\";\r\n\r\n// TODO: when a user owns DecentraName first time, front end must call setApprovalForAll on DecentraName contract with operater as address(this) and approved as true with owner sign\r\n\r\ncontract DecentraNameController is IDecentraNameController, Controllable {\r\n\r\n    DecentraName public decentraName;\r\n\r\n    constructor() {\r\n        decentraName = new DecentraName();\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) external virtual override view returns (address) {\r\n        return decentraName.ownerOf(tokenId);\r\n    }\r\n\r\n    function isApprovedOrOwner(address spender, uint256 tokenId) external virtual override view returns (bool) {\r\n        return decentraName.isApprovedOrOwner(spender, tokenId);\r\n    }\r\n\r\n    function existsToken(uint256 tokenId) external virtual override view returns (bool) {\r\n        // TODO: it shoud not return true for expired domain\r\n        return decentraName.existsToken(tokenId);\r\n    }\r\n\r\n    function burnToken(uint256 tokenId) external virtual override onlyController {\r\n        /* TODO: signature verification has to be done before calling burn on dweb token. \r\n         *       Additional param may required for this method. It can be called bycontroller\r\n         * TODO: how to use expiry here\r\n         */\r\n        decentraName.burnToken(tokenId);\r\n    }\r\n\r\n    function mintToken(address owner, uint256 id) external virtual override {\r\n        /* TODO: signature verification has to be done before calling mintToken on dweb token. \r\n         *       Additional param may required for this method.\r\n         */\r\n        decentraName.mintToken(owner, id);\r\n    }\r\n\r\n    function mintTokenForTLD(address owner, uint256 id) external virtual override onlyController {\r\n        decentraName.mintToken(owner, id);\r\n    }\r\n\r\n    function transferToken(address to, uint256 id) external virtual override {\r\n        /* TODO: signature verification has to be done before calling transferToken on dweb token. \r\n         *       Additional param may required for this method. can only be done by owner. signature verification will work here\r\n         */\r\n        decentraName.transferToken(to, id);\r\n    }\r\n\r\n\r\n}"
    },
    "contracts/root/Controllable.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract Controllable is Ownable {\r\n    mapping(address => bool) public controllers;\r\n\r\n    event ControllerChanged(address indexed controller, bool enabled);\r\n\r\n    modifier onlyController {\r\n        require(\r\n            controllers[msg.sender],\r\n            \"Controllable: Caller is not a controller\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setController(address controller, bool enabled) public onlyOwner {\r\n        controllers[controller] = enabled;\r\n        emit ControllerChanged(controller, enabled);\r\n    }\r\n}\r\n"
    },
    "contracts/decentraname/IDecentraNameController.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\n\r\ninterface IDecentraNameController {\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n\r\n    function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\r\n\r\n    function existsToken(uint256 tokenId) external view returns (bool);\r\n\r\n    function burnToken(uint256 tokenId) external;\r\n\r\n    function mintToken(address owner, uint256 id) external;\r\n\r\n    function mintTokenForTLD(address owner, uint256 id) external;\r\n\r\n    function transferToken(address to, uint256 id) external;\r\n}"
    },
    "contracts/root/Root.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"../registry/ENS.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./Controllable.sol\";\r\nimport \"../decentraname/IDecentraNameController.sol\";\r\n\r\ncontract Root is Ownable, Controllable {\r\n    bytes32 public constant rootNode = bytes32(0);\r\n    uint public constant GRACE_PERIOD = 90 days;\r\n\r\n    bytes4 private constant INTERFACE_META_ID =\r\n        bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n    // bytes4 constant private RECLAIM_ID = bytes4(keccak256(\"reclaim(uint256,address)\"));\r\n\r\n    ENS public ens;\r\n\r\n    // The dweb NFT token\r\n    IDecentraNameController public decentraNameController;\r\n\r\n    // A map of expiry times\r\n    mapping(uint256=>uint) expiries;\r\n\r\n    // TODO: does locked makes sense now?\r\n    mapping(bytes32 => bool) public locked;\r\n\r\n    event TLDLocked(bytes32 indexed label);\r\n    event NameMigrated(uint256 indexed id, address indexed owner, uint expires);\r\n    event NameRegistered(uint256 indexed id, address indexed owner, uint expires);\r\n    event NameRenewed(uint256 indexed id, uint expires);\r\n\r\n    constructor(ENS _ens, IDecentraNameController _decentraNameController) {\r\n        ens = _ens;\r\n        decentraNameController =  _decentraNameController;\r\n    }\r\n\r\n    function setSubnodeOwner(bytes32 label, address owner)\r\n        external\r\n        onlyController\r\n    {\r\n        require(!locked[label]);\r\n        ens.setSubnodeOwner(rootNode, label, owner);\r\n    }\r\n\r\n    function setResolver(address resolver) external onlyOwner {\r\n        ens.setResolver(rootNode, resolver);\r\n    }\r\n\r\n    function lock(bytes32 label) external onlyOwner {\r\n        emit TLDLocked(label);\r\n        locked[label] = true;\r\n    }\r\n\r\n    function setRootDomainOwner() external onlyOwner {\r\n        decentraNameController.mintTokenForTLD(address(this), uint256(rootNode));\r\n    }\r\n\r\n    // Returns the expiration timestamp of the specified id.\r\n    function nameExpires(uint256 id) external view returns(uint) {\r\n        return expiries[id];\r\n    }\r\n\r\n    // Returns true iff the specified name is available for registration.\r\n    function available(uint256 id) public view returns(bool) {\r\n        // Not available if it's registered here or in its grace period.\r\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Register a name.\r\n     * @param id The token ID (keccak256 of the label).\r\n     * @param owner The address that should own the registration.\r\n     * @param duration Duration in seconds for the registration.\r\n     */\r\n    function register(uint256 id, address owner, uint duration) external returns(uint) {\r\n      return _register(id, owner, duration, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Register a name, without modifying the registry.\r\n     * @param id The token ID (keccak256 of the label).\r\n     * @param owner The address that should own the registration.\r\n     * @param duration Duration in seconds for the registration.\r\n     */\r\n    function registerOnly(uint256 id, address owner, uint duration) external returns(uint) {\r\n      return _register(id, owner, duration, false);\r\n    }\r\n\r\n    function _register(uint256 id, address owner, uint duration, bool updateRegistry) internal onlyController returns(uint) {\r\n        require(available(id));\r\n        require(block.timestamp + duration + GRACE_PERIOD > block.timestamp + GRACE_PERIOD); // Prevent future overflow\r\n\r\n        expiries[id] = block.timestamp + duration;\r\n        if(decentraNameController.existsToken(id)) {\r\n            // Name was previously owned, and expired\r\n            decentraNameController.burnToken(id);\r\n        }\r\n        decentraNameController.mintTokenForTLD(owner, id);\r\n        if(updateRegistry) {\r\n            ens.createSubnode(rootNode, bytes32(id), owner);\r\n        }\r\n\r\n        emit NameRegistered(id, owner, block.timestamp + duration);\r\n\r\n        return block.timestamp + duration;\r\n    }\r\n\r\n    function renew(uint256 id, uint duration) external onlyController returns(uint) {\r\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\r\n        require(expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD); // Prevent future overflow\r\n\r\n        expiries[id] += duration;\r\n        emit NameRenewed(id, expiries[id]);\r\n        return expiries[id];\r\n    }\r\n\r\n    // TODO: revisit this. we may not require reclaim as every url is now NFT\r\n    // TODO: review: removing below methods as it is no logner required. Now ownership is no longer managed in ens but in decentraName only\r\n    /**\r\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\r\n     */\r\n    // function reclaim(uint256 id, address owner) external override live {\r\n    //     require(decentraNameController.isApprovedOrOwner(msg.sender, id));\r\n    //     ens.setSubnodeOwner(baseNode, bytes32(id), owner);\r\n    // }\r\n\r\n    function supportsInterface(bytes4 interfaceID)\r\n        external\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return interfaceID == INTERFACE_META_ID;\r\n    }\r\n}\r\n"
    },
    "contracts/registry/ENS.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\ninterface ENS {\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n    // Logged when an operator is added or removed.\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual;\r\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual;\r\n    function createSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual;\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external virtual returns(bytes32);\r\n    function setResolver(bytes32 node, address resolver) external virtual;\r\n    function setOwner(bytes32 node, address owner) external virtual;\r\n    function createSubnode(bytes32 node, bytes32 label, address owner) external virtual returns(bytes32);\r\n    function setTTL(bytes32 node, uint64 ttl) external virtual;\r\n    function setApprovalForAll(address operator, bool approved) external virtual;\r\n    function owner(bytes32 node) external virtual view returns (address);\r\n    function resolver(bytes32 node) external virtual view returns (address);\r\n    function ttl(bytes32 node) external virtual view returns (uint64);\r\n    function recordExists(bytes32 node) external virtual view returns (bool);\r\n    function isApprovedForAll(address owner, address operator) external virtual view returns (bool);\r\n}\r\n"
    },
    "contracts/ethregistrar/RootRegistrarController.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nimport \"./PriceOracle.sol\";\r\nimport \"../root/Root.sol\";\r\nimport \"./StringUtils.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../resolvers/Resolver.sol\";\r\n\r\n/**\r\n * @dev A registrar controller for registering and renewing names at fixed cost.\r\n */\r\ncontract RootRegistrarController is Ownable {\r\n    using StringUtils for *;\r\n\r\n    uint constant public MIN_REGISTRATION_DURATION = 28 days;\r\n\r\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n    bytes4 constant private COMMITMENT_CONTROLLER_ID = bytes4(\r\n        keccak256(\"rentPrice(string,uint256)\") ^\r\n        keccak256(\"available(string)\") ^\r\n        keccak256(\"makeCommitment(string,address,bytes32)\") ^\r\n        keccak256(\"commit(bytes32)\") ^\r\n        keccak256(\"register(string,address,uint256,bytes32)\") ^\r\n        keccak256(\"renew(string,uint256)\")\r\n    );\r\n\r\n    bytes4 constant private COMMITMENT_WITH_CONFIG_CONTROLLER_ID = bytes4(\r\n        keccak256(\"registerWithConfig(string,address,uint256,bytes32,address,address)\") ^\r\n        keccak256(\"makeCommitmentWithConfig(string,address,bytes32,address,address)\")\r\n    );\r\n\r\n    Root root;\r\n    PriceOracle prices;\r\n    uint public minCommitmentAge;\r\n    uint public maxCommitmentAge;\r\n\r\n    mapping(bytes32=>uint) public commitments;\r\n\r\n    event NameRegistered(string name, bytes32 indexed label, address indexed owner, uint cost, uint expires);\r\n    event NameRenewed(string name, bytes32 indexed label, uint cost, uint expires);\r\n    event NewPriceOracle(address indexed oracle);\r\n\r\n    constructor(Root _root, PriceOracle _prices, uint _minCommitmentAge, uint _maxCommitmentAge) {\r\n        require(_maxCommitmentAge > _minCommitmentAge);\r\n\r\n        root = _root;\r\n        prices = _prices;\r\n        minCommitmentAge = _minCommitmentAge;\r\n        maxCommitmentAge = _maxCommitmentAge;\r\n    }\r\n\r\n    function rentPrice(string memory name, uint duration) view public returns(uint) {\r\n        bytes32 hash = keccak256(bytes(name));\r\n        return prices.price(name, root.nameExpires(uint256(hash)), duration);\r\n    }\r\n\r\n    function valid(string memory name) public pure returns(bool) {\r\n        return name.strlen() >= 3;\r\n    }\r\n\r\n    function available(string memory name) public view returns(bool) {\r\n        bytes32 label = keccak256(bytes(name));\r\n        return valid(name) && root.available(uint256(label));\r\n    }\r\n\r\n    function makeCommitment(string memory name, address owner, bytes32 secret) pure public returns(bytes32) {\r\n        return makeCommitmentWithConfig(name, owner, secret, address(0), address(0));\r\n    }\r\n\r\n    function makeCommitmentWithConfig(string memory name, address owner, bytes32 secret, address resolver, address addr) pure public returns(bytes32) {\r\n        bytes32 label = keccak256(bytes(name));\r\n        if (resolver == address(0) && addr == address(0)) {\r\n            return keccak256(abi.encodePacked(label, owner, secret));\r\n        }\r\n        require(resolver != address(0));\r\n        return keccak256(abi.encodePacked(label, owner, resolver, addr, secret));\r\n    }\r\n\r\n    function commit(bytes32 commitment) public {\r\n        require(commitments[commitment] + maxCommitmentAge < block.timestamp);\r\n        commitments[commitment] = block.timestamp;\r\n    }\r\n\r\n    function register(string calldata name, address owner, uint duration, bytes32 secret) external payable {\r\n      registerWithConfig(name, owner, duration, secret, address(0), address(0));\r\n    }\r\n\r\n    function registerWithConfig(string memory name, address owner, uint duration, bytes32 secret, address resolver, address addr) public payable {\r\n        // TODO: name has to be TLD. put check for this\r\n        bytes32 commitment = makeCommitmentWithConfig(name, owner, secret, resolver, addr);\r\n        uint cost = _consumeCommitment(name, duration, commitment);\r\n\r\n        bytes32 label = keccak256(bytes(name));\r\n        // The nodehash of this label\r\n        bytes32 tokenId = keccak256(abi.encodePacked(root.rootNode(), label));\r\n\r\n        uint expires;\r\n        // TODO: Future release : skipping setting revords for now\r\n        // ---\r\n        // if(resolver != address(0)) {\r\n        //     // Set this contract as the (temporary) owner, giving it\r\n        //     // permission to set up the resolver.\r\n        //     expires = root.register(uint256(tokenId), address(this), duration);\r\n\r\n        //     // Set the resolver\r\n        //     root.ens().setResolver(tokenId, resolver);\r\n\r\n        //     // Configure the resolver\r\n        //     if (addr != address(0)) {\r\n        //         Resolver(resolver).setAddr(tokenId, addr);\r\n        //     }\r\n\r\n        //     // Now transfer full ownership to the expeceted owner\r\n        //     //base.reclaim(tokenId, owner);\r\n            \r\n        //     //base.transferFrom(address(this), owner, tokenId);\r\n        //     // TODO: can we improve below?\r\n        //     root.decentraNameController().decentraName().safeTransferFrom(address(this), owner, uint256(tokenId));\r\n        // } else \r\n        // ---\r\n        {\r\n            require(addr == address(0));\r\n            expires = root.register(uint256(tokenId), owner, duration);\r\n        }\r\n\r\n        emit NameRegistered(name, label, owner, cost, expires);\r\n\r\n        // Refund any extra payment\r\n        if(msg.value > cost) {\r\n            payable(msg.sender).transfer(msg.value - cost);\r\n        }\r\n    }\r\n\r\n    function renew(string calldata name, uint duration) external payable {\r\n        uint cost = rentPrice(name, duration);\r\n        require(msg.value >= cost);\r\n\r\n        bytes32 label = keccak256(bytes(name));\r\n        uint expires = root.renew(uint256(label), duration);\r\n\r\n        if(msg.value > cost) {\r\n            payable(msg.sender).transfer(msg.value - cost);\r\n        }\r\n\r\n        emit NameRenewed(name, label, cost, expires);\r\n    }\r\n\r\n    function setPriceOracle(PriceOracle _prices) public onlyOwner {\r\n        prices = _prices;\r\n        emit NewPriceOracle(address(prices));\r\n    }\r\n\r\n    function setCommitmentAges(uint _minCommitmentAge, uint _maxCommitmentAge) public onlyOwner {\r\n        minCommitmentAge = _minCommitmentAge;\r\n        maxCommitmentAge = _maxCommitmentAge;\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        payable(msg.sender).transfer(address(this).balance);        \r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\r\n        return interfaceID == INTERFACE_META_ID ||\r\n               interfaceID == COMMITMENT_CONTROLLER_ID ||\r\n               interfaceID == COMMITMENT_WITH_CONFIG_CONTROLLER_ID;\r\n    }\r\n\r\n    function _consumeCommitment(string memory name, uint duration, bytes32 commitment) internal returns (uint256) {\r\n        // Require a valid commitment\r\n        require(commitments[commitment] + minCommitmentAge <= block.timestamp);\r\n\r\n        // If the commitment is too old, or the name is registered, stop\r\n        require(commitments[commitment] + maxCommitmentAge > block.timestamp);\r\n        require(available(name));\r\n\r\n        delete(commitments[commitment]);\r\n\r\n        uint cost = rentPrice(name, duration);\r\n        require(duration >= MIN_REGISTRATION_DURATION);\r\n        require(msg.value >= cost);\r\n\r\n        return cost;\r\n    }\r\n}\r\n"
    },
    "contracts/ethregistrar/PriceOracle.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\ninterface PriceOracle {\r\n    /**\r\n     * @dev Returns the price to register or renew a name.\r\n     * @param name The name being registered or renewed.\r\n     * @param expires When the name presently expires (0 if this is a new registration).\r\n     * @param duration How long the name is being registered or extended for, in seconds.\r\n     * @return The price of this renewal or registration, in wei.\r\n     */\r\n    function price(string calldata name, uint expires, uint duration) external view returns(uint);\r\n}\r\n"
    },
    "contracts/ethregistrar/StringUtils.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nlibrary StringUtils {\r\n    /**\r\n     * @dev Returns the length of a given string\r\n     *\r\n     * @param s The string to measure the length of\r\n     * @return The length of the input string\r\n     */\r\n    function strlen(string memory s) internal pure returns (uint) {\r\n        uint len;\r\n        uint i = 0;\r\n        uint bytelength = bytes(s).length;\r\n        for(len = 0; i < bytelength; len++) {\r\n            bytes1 b = bytes(s)[i];\r\n            if(b < 0x80) {\r\n                i += 1;\r\n            } else if (b < 0xE0) {\r\n                i += 2;\r\n            } else if (b < 0xF0) {\r\n                i += 3;\r\n            } else if (b < 0xF8) {\r\n                i += 4;\r\n            } else if (b < 0xFC) {\r\n                i += 5;\r\n            } else {\r\n                i += 6;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/Resolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * A generic resolver interface which includes all the functions including the ones deprecated\r\n */\r\ninterface Resolver{\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\r\n    event NameChanged(bytes32 indexed node, string name);\r\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\r\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\r\n    /* Deprecated events */\r\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\r\n\r\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);\r\n    function addr(bytes32 node) external view returns (address);\r\n    function addr(bytes32 node, uint coinType) external view returns(bytes memory);\r\n    function contenthash(bytes32 node) external view returns (bytes memory);\r\n    function dnsrr(bytes32 node) external view returns (bytes memory);\r\n    function name(bytes32 node) external view returns (string memory);\r\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\r\n    function text(bytes32 node, string calldata key) external view returns (string memory);\r\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\r\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\r\n    function setAddr(bytes32 node, address addr) external;\r\n    function setAddr(bytes32 node, uint coinType, bytes calldata a) external;\r\n    function setContenthash(bytes32 node, bytes calldata hash) external;\r\n    function setDnsrr(bytes32 node, bytes calldata data) external;\r\n    function setName(bytes32 node, string calldata _name) external;\r\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\r\n    function setText(bytes32 node, string calldata key, string calldata value) external;\r\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external;\r\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool);\r\n    function multicall(bytes[] calldata data) external returns(bytes[] memory results);\r\n\r\n    /* Deprecated functions */\r\n    function content(bytes32 node) external view returns (bytes32);\r\n    function multihash(bytes32 node) external view returns (bytes memory);\r\n    function setContent(bytes32 node, bytes32 hash) external;\r\n    function setMultihash(bytes32 node, bytes calldata hash) external;\r\n}\r\n"
    },
    "contracts/ethregistrar/BulkRenewal.sol": {
      "content": "pragma solidity >=0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../registry/ENS.sol\";\r\nimport \"./RootRegistrarController.sol\";\r\nimport \"../resolvers/Resolver.sol\";\r\n\r\ncontract BulkRenewal {\r\n    bytes32 constant private ETH_NAMEHASH = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\r\n    bytes4 constant private REGISTRAR_CONTROLLER_ID = 0x018fac06;\r\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n    bytes4 constant public BULK_RENEWAL_ID = bytes4(\r\n        keccak256(\"rentPrice(string[],uint)\") ^\r\n        keccak256(\"renewAll(string[],uint\")\r\n    );\r\n\r\n    ENS public ens;\r\n\r\n    constructor(ENS _ens) public {\r\n        ens = _ens;\r\n    }\r\n\r\n    function getController() internal view returns(RootRegistrarController) {\r\n        Resolver r = Resolver(ens.resolver(ETH_NAMEHASH));\r\n        return RootRegistrarController(r.interfaceImplementer(ETH_NAMEHASH, REGISTRAR_CONTROLLER_ID));\r\n    }\r\n\r\n    function rentPrice(string[] calldata names, uint duration) external view returns(uint total) {\r\n        RootRegistrarController controller = getController();\r\n        for(uint i = 0; i < names.length; i++) {\r\n            total += controller.rentPrice(names[i], duration);\r\n        }\r\n    }\r\n\r\n    function renewAll(string[] calldata names, uint duration) external payable {\r\n        RootRegistrarController controller = getController();\r\n        for(uint i = 0; i < names.length; i++) {\r\n            uint cost = controller.rentPrice(names[i], duration);\r\n            controller.renew{value:cost}(names[i], duration);\r\n        }\r\n        // Send any excess funds back\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\r\n         return interfaceID == INTERFACE_META_ID || interfaceID == BULK_RENEWAL_ID;\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/PublicResolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nimport \"../registry/ENS.sol\";\r\nimport \"./profiles/ABIResolver.sol\";\r\nimport \"./profiles/AddrResolver.sol\";\r\nimport \"./profiles/ContentHashResolver.sol\";\r\nimport \"./profiles/DNSResolver.sol\";\r\nimport \"./profiles/InterfaceResolver.sol\";\r\nimport \"./profiles/NameResolver.sol\";\r\nimport \"./profiles/PubkeyResolver.sol\";\r\nimport \"./profiles/TextResolver.sol\";\r\n\r\ninterface INameWrapper {\r\n    function ownerOf(uint256 id) external view returns (address);\r\n}\r\n\r\n/**\r\n * A simple resolver anyone can use; only allows the owner of a node to set its\r\n * address.\r\n */\r\ncontract PublicResolver is ABIResolver, AddrResolver, ContentHashResolver, DNSResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver {\r\n    ENS ens;\r\n    INameWrapper nameWrapper;\r\n\r\n    /**\r\n     * A mapping of operators. An address that is authorised for an address\r\n     * may make any changes to the name that the owner could, but may not update\r\n     * the set of authorisations.\r\n     * (owner, operator) => approved\r\n     */\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // Logged when an operator is added or removed.\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    constructor(ENS _ens, INameWrapper wrapperAddress){\r\n        ens = _ens;\r\n        nameWrapper = wrapperAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external{\r\n        require(\r\n            msg.sender != operator,\r\n            \"ERC1155: setting approval status for self\"\r\n        );\r\n\r\n        _operatorApprovals[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function isAuthorised(bytes32 node) internal override view returns(bool) {\r\n        address owner = ens.owner(node);\r\n        if(owner == address(nameWrapper) ){\r\n            owner = nameWrapper.ownerOf(uint256(node));\r\n        }\r\n        return owner == msg.sender || isApprovedForAll(owner, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) public view returns (bool){\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    function multicall(bytes[] calldata data) external returns(bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        for(uint i = 0; i < data.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n            require(success);\r\n            results[i] = result;\r\n        }\r\n        return results;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) virtual override(ABIResolver, AddrResolver, ContentHashResolver, DNSResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver) public pure returns(bool) {\r\n        return super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/ABIResolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\nimport \"../ResolverBase.sol\";\r\n\r\nabstract contract ABIResolver is ResolverBase {\r\n    bytes4 constant private ABI_INTERFACE_ID = 0x2203ab56;\r\n\r\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n\r\n    mapping(bytes32=>mapping(uint256=>bytes)) abis;\r\n\r\n    /**\r\n     * Sets the ABI associated with an ENS node.\r\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\r\n     * the empty string.\r\n     * @param node The node to update.\r\n     * @param contentType The content type of the ABI\r\n     * @param data The ABI data.\r\n     */\r\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external authorised(node) {\r\n        // Content types must be powers of 2\r\n        require(((contentType - 1) & contentType) == 0);\r\n\r\n        abis[node][contentType] = data;\r\n        emit ABIChanged(node, contentType);\r\n    }\r\n\r\n    /**\r\n     * Returns the ABI associated with an ENS node.\r\n     * Defined in EIP205.\r\n     * @param node The ENS node to query\r\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\r\n     * @return contentType The content type of the return value\r\n     * @return data The ABI data\r\n     */\r\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory) {\r\n        mapping(uint256=>bytes) storage abiset = abis[node];\r\n\r\n        for (uint256 contentType = 1; contentType <= contentTypes; contentType <<= 1) {\r\n            if ((contentType & contentTypes) != 0 && abiset[contentType].length > 0) {\r\n                return (contentType, abiset[contentType]);\r\n            }\r\n        }\r\n\r\n        return (0, bytes(\"\"));\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\r\n        return interfaceID == ABI_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/AddrResolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\nimport \"../ResolverBase.sol\";\r\n\r\nabstract contract AddrResolver is ResolverBase {\r\n    bytes4 constant private ADDR_INTERFACE_ID = 0x3b3b57de;\r\n    bytes4 constant private ADDRESS_INTERFACE_ID = 0xf1cb7e06;\r\n    uint constant private COIN_TYPE_ETH = 60;\r\n\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\r\n\r\n    mapping(bytes32=>mapping(uint=>bytes)) _addresses;\r\n\r\n    /**\r\n     * Sets the address associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param a The address to set.\r\n     */\r\n    function setAddr(bytes32 node, address a) external authorised(node) {\r\n        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));\r\n    }\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) public view returns (address payable) {\r\n        bytes memory a = addr(node, COIN_TYPE_ETH);\r\n        if(a.length == 0) {\r\n            return payable(0);\r\n        }\r\n        return bytesToAddress(a);\r\n    }\r\n\r\n    function setAddr(bytes32 node, uint coinType, bytes memory a) public authorised(node) {\r\n        emit AddressChanged(node, coinType, a);\r\n        if(coinType == COIN_TYPE_ETH) {\r\n            emit AddrChanged(node, bytesToAddress(a));\r\n        }\r\n        _addresses[node][coinType] = a;\r\n    }\r\n\r\n    function addr(bytes32 node, uint coinType) public view returns(bytes memory) {\r\n        return _addresses[node][coinType];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\r\n        return interfaceID == ADDR_INTERFACE_ID || interfaceID == ADDRESS_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n\r\n    function bytesToAddress(bytes memory b) internal pure returns(address payable a) {\r\n        require(b.length == 20);\r\n        assembly {\r\n            a := div(mload(add(b, 32)), exp(256, 12))\r\n        }\r\n    }\r\n\r\n    function addressToBytes(address a) internal pure returns(bytes memory b) {\r\n        b = new bytes(20);\r\n        assembly {\r\n            mstore(add(b, 32), mul(a, exp(256, 12)))\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/ContentHashResolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\nimport \"../ResolverBase.sol\";\r\n\r\nabstract contract ContentHashResolver is ResolverBase {\r\n    bytes4 constant private CONTENT_HASH_INTERFACE_ID = 0xbc1c58d1;\r\n\r\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\r\n\r\n    mapping(bytes32=>bytes) hashes;\r\n\r\n    /**\r\n     * Sets the contenthash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param hash The contenthash to set\r\n     */\r\n    function setContenthash(bytes32 node, bytes calldata hash) external authorised(node) {\r\n        hashes[node] = hash;\r\n        emit ContenthashChanged(node, hash);\r\n    }\r\n\r\n    /**\r\n     * Returns the contenthash associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated contenthash.\r\n     */\r\n    function contenthash(bytes32 node) external view returns (bytes memory) {\r\n        return hashes[node];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\r\n        return interfaceID == CONTENT_HASH_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/DNSResolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\nimport \"../ResolverBase.sol\";\r\nimport \"../../dnssec-oracle/RRUtils.sol\";\r\n\r\nabstract contract DNSResolver is ResolverBase {\r\n    using RRUtils for *;\r\n    using BytesUtils for bytes;\r\n\r\n    bytes4 constant private DNS_RECORD_INTERFACE_ID = 0xa8fa5682;\r\n    bytes4 constant private DNS_ZONE_INTERFACE_ID = 0x5c47637c;\r\n\r\n    // DNSRecordChanged is emitted whenever a given node/name/resource's RRSET is updated.\r\n    event DNSRecordChanged(bytes32 indexed node, bytes name, uint16 resource, bytes record);\r\n    // DNSRecordDeleted is emitted whenever a given node/name/resource's RRSET is deleted.\r\n    event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource);\r\n    // DNSZoneCleared is emitted whenever a given node's zone information is cleared.\r\n    event DNSZoneCleared(bytes32 indexed node);\r\n\r\n    // DNSZonehashChanged is emitted whenever a given node's zone hash is updated.\r\n    event DNSZonehashChanged(bytes32 indexed node, bytes lastzonehash, bytes zonehash);\r\n\r\n    // Zone hashes for the domains.\r\n    // A zone hash is an EIP-1577 content hash in binary format that should point to a\r\n    // resource containing a single zonefile.\r\n    // node => contenthash\r\n    mapping(bytes32=>bytes) private zonehashes;\r\n\r\n    // Version the mapping for each zone.  This allows users who have lost\r\n    // track of their entries to effectively delete an entire zone by bumping\r\n    // the version number.\r\n    // node => version\r\n    mapping(bytes32=>uint256) private versions;\r\n\r\n    // The records themselves.  Stored as binary RRSETs\r\n    // node => version => name => resource => data\r\n    mapping(bytes32=>mapping(uint256=>mapping(bytes32=>mapping(uint16=>bytes)))) private records;\r\n\r\n    // Count of number of entries for a given name.  Required for DNS resolvers\r\n    // when resolving wildcards.\r\n    // node => version => name => number of records\r\n    mapping(bytes32=>mapping(uint256=>mapping(bytes32=>uint16))) private nameEntriesCount;\r\n\r\n    /**\r\n     * Set one or more DNS records.  Records are supplied in wire-format.\r\n     * Records with the same node/name/resource must be supplied one after the\r\n     * other to ensure the data is updated correctly. For example, if the data\r\n     * was supplied:\r\n     *     a.example.com IN A 1.2.3.4\r\n     *     a.example.com IN A 5.6.7.8\r\n     *     www.example.com IN CNAME a.example.com.\r\n     * then this would store the two A records for a.example.com correctly as a\r\n     * single RRSET, however if the data was supplied:\r\n     *     a.example.com IN A 1.2.3.4\r\n     *     www.example.com IN CNAME a.example.com.\r\n     *     a.example.com IN A 5.6.7.8\r\n     * then this would store the first A record, the CNAME, then the second A\r\n     * record which would overwrite the first.\r\n     *\r\n     * @param node the namehash of the node for which to set the records\r\n     * @param data the DNS wire format records to set\r\n     */\r\n    function setDNSRecords(bytes32 node, bytes calldata data) external authorised(node) {\r\n        uint16 resource = 0;\r\n        uint256 offset = 0;\r\n        bytes memory name;\r\n        bytes memory value;\r\n        bytes32 nameHash;\r\n        // Iterate over the data to add the resource records\r\n        for (RRUtils.RRIterator memory iter = data.iterateRRs(0); !iter.done(); iter.next()) {\r\n            if (resource == 0) {\r\n                resource = iter.dnstype;\r\n                name = iter.name();\r\n                nameHash = keccak256(abi.encodePacked(name));\r\n                value = bytes(iter.rdata());\r\n            } else {\r\n                bytes memory newName = iter.name();\r\n                if (resource != iter.dnstype || !name.equals(newName)) {\r\n                    setDNSRRSet(node, name, resource, data, offset, iter.offset - offset, value.length == 0);\r\n                    resource = iter.dnstype;\r\n                    offset = iter.offset;\r\n                    name = newName;\r\n                    nameHash = keccak256(name);\r\n                    value = bytes(iter.rdata());\r\n                }\r\n            }\r\n        }\r\n        if (name.length > 0) {\r\n            setDNSRRSet(node, name, resource, data, offset, data.length - offset, value.length == 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Obtain a DNS record.\r\n     * @param node the namehash of the node for which to fetch the record\r\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\r\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\r\n     * @return the DNS record in wire format if present, otherwise empty\r\n     */\r\n    function dnsRecord(bytes32 node, bytes32 name, uint16 resource) public view returns (bytes memory) {\r\n        return records[node][versions[node]][name][resource];\r\n    }\r\n\r\n    /**\r\n     * Check if a given node has records.\r\n     * @param node the namehash of the node for which to check the records\r\n     * @param name the namehash of the node for which to check the records\r\n     */\r\n    function hasDNSRecords(bytes32 node, bytes32 name) public view returns (bool) {\r\n        return (nameEntriesCount[node][versions[node]][name] != 0);\r\n    }\r\n\r\n    /**\r\n     * Clear all information for a DNS zone.\r\n     * @param node the namehash of the node for which to clear the zone\r\n     */\r\n    function clearDNSZone(bytes32 node) public authorised(node) {\r\n        versions[node]++;\r\n        emit DNSZoneCleared(node);\r\n    }\r\n\r\n    /**\r\n     * setZonehash sets the hash for the zone.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param hash The zonehash to set\r\n     */\r\n    function setZonehash(bytes32 node, bytes calldata hash) external authorised(node) {\r\n        bytes memory oldhash = zonehashes[node];\r\n        zonehashes[node] = hash;\r\n        emit DNSZonehashChanged(node, oldhash, hash);\r\n    }\r\n\r\n    /**\r\n     * zonehash obtains the hash for the zone.\r\n     * @param node The ENS node to query.\r\n     * @return The associated contenthash.\r\n     */\r\n    function zonehash(bytes32 node) external view returns (bytes memory) {\r\n        return zonehashes[node];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\r\n        return interfaceID == DNS_RECORD_INTERFACE_ID ||\r\n               interfaceID == DNS_ZONE_INTERFACE_ID ||\r\n               super.supportsInterface(interfaceID);\r\n    }\r\n\r\n    function setDNSRRSet(\r\n        bytes32 node,\r\n        bytes memory name,\r\n        uint16 resource,\r\n        bytes memory data,\r\n        uint256 offset,\r\n        uint256 size,\r\n        bool deleteRecord) private\r\n    {\r\n        uint256 version = versions[node];\r\n        bytes32 nameHash = keccak256(name);\r\n        bytes memory rrData = data.substring(offset, size);\r\n        if (deleteRecord) {\r\n            if (records[node][version][nameHash][resource].length != 0) {\r\n                nameEntriesCount[node][version][nameHash]--;\r\n            }\r\n            delete(records[node][version][nameHash][resource]);\r\n            emit DNSRecordDeleted(node, name, resource);\r\n        } else {\r\n            if (records[node][version][nameHash][resource].length == 0) {\r\n                nameEntriesCount[node][version][nameHash]++;\r\n            }\r\n            records[node][version][nameHash][resource] = rrData;\r\n            emit DNSRecordChanged(node, name, resource, rrData);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/InterfaceResolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\nimport \"../ResolverBase.sol\";\r\nimport \"./AddrResolver.sol\";\r\n\r\nabstract contract InterfaceResolver is ResolverBase, AddrResolver {\r\n    bytes4 constant private INTERFACE_INTERFACE_ID = bytes4(keccak256(\"interfaceImplementer(bytes32,bytes4)\"));\r\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\r\n\r\n    event InterfaceChanged(bytes32 indexed node, bytes4 indexed interfaceID, address implementer);\r\n\r\n    mapping(bytes32=>mapping(bytes4=>address)) interfaces;\r\n\r\n    /**\r\n     * Sets an interface associated with a name.\r\n     * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\r\n     * @param node The node to update.\r\n     * @param interfaceID The EIP 165 interface ID.\r\n     * @param implementer The address of a contract that implements this interface for this node.\r\n     */\r\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external authorised(node) {\r\n        interfaces[node][interfaceID] = implementer;\r\n        emit InterfaceChanged(node, interfaceID, implementer);\r\n    }\r\n\r\n    /**\r\n     * Returns the address of a contract that implements the specified interface for this name.\r\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\r\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\r\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\r\n     * will be returned.\r\n     * @param node The ENS node to query.\r\n     * @param interfaceID The EIP 165 interface ID to check for.\r\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\r\n     */\r\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address) {\r\n        address implementer = interfaces[node][interfaceID];\r\n        if(implementer != address(0)) {\r\n            return implementer;\r\n        }\r\n\r\n        address a = addr(node);\r\n        if(a == address(0)) {\r\n            return address(0);\r\n        }\r\n\r\n        (bool success, bytes memory returnData) = a.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\", INTERFACE_META_ID));\r\n        if(!success || returnData.length < 32 || returnData[31] == 0) {\r\n            // EIP 165 not supported by target\r\n            return address(0);\r\n        }\r\n\r\n        (success, returnData) = a.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\", interfaceID));\r\n        if(!success || returnData.length < 32 || returnData[31] == 0) {\r\n            // Specified interface not supported by target\r\n            return address(0);\r\n        }\r\n\r\n        return a;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) virtual override(AddrResolver, ResolverBase) public pure returns(bool) {\r\n        return interfaceID == INTERFACE_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/NameResolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\nimport \"../ResolverBase.sol\";\r\n\r\nabstract contract NameResolver is ResolverBase {\r\n    bytes4 constant private NAME_INTERFACE_ID = 0x691f3431;\r\n\r\n    event NameChanged(bytes32 indexed node, string name);\r\n\r\n    mapping(bytes32=>string) names;\r\n\r\n    /**\r\n     * Sets the name associated with an ENS node, for reverse records.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param name The name to set.\r\n     */\r\n    function setName(bytes32 node, string calldata name) external authorised(node) {\r\n        names[node] = name;\r\n        emit NameChanged(node, name);\r\n    }\r\n\r\n    /**\r\n     * Returns the name associated with an ENS node, for reverse records.\r\n     * Defined in EIP181.\r\n     * @param node The ENS node to query.\r\n     * @return The associated name.\r\n     */\r\n    function name(bytes32 node) external view returns (string memory) {\r\n        return names[node];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\r\n        return interfaceID == NAME_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/PubkeyResolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\nimport \"../ResolverBase.sol\";\r\n\r\nabstract contract PubkeyResolver is ResolverBase {\r\n    bytes4 constant private PUBKEY_INTERFACE_ID = 0xc8690233;\r\n\r\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n\r\n    struct PublicKey {\r\n        bytes32 x;\r\n        bytes32 y;\r\n    }\r\n\r\n    mapping(bytes32=>PublicKey) pubkeys;\r\n\r\n    /**\r\n     * Sets the SECP256k1 public key associated with an ENS node.\r\n     * @param node The ENS node to query\r\n     * @param x the X coordinate of the curve point for the public key.\r\n     * @param y the Y coordinate of the curve point for the public key.\r\n     */\r\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external authorised(node) {\r\n        pubkeys[node] = PublicKey(x, y);\r\n        emit PubkeyChanged(node, x, y);\r\n    }\r\n\r\n    /**\r\n     * Returns the SECP256k1 public key associated with an ENS node.\r\n     * Defined in EIP 619.\r\n     * @param node The ENS node to query\r\n     * @return x The X coordinate of the curve point for the public key.\r\n     * @return y The Y coordinate of the curve point for the public key.\r\n     */\r\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y) {\r\n        return (pubkeys[node].x, pubkeys[node].y);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\r\n        return interfaceID == PUBKEY_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/profiles/TextResolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\nimport \"../ResolverBase.sol\";\r\n\r\nabstract contract TextResolver is ResolverBase {\r\n    bytes4 constant private TEXT_INTERFACE_ID = 0x59d1d43c;\r\n\r\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\r\n\r\n    mapping(bytes32=>mapping(string=>string)) texts;\r\n\r\n    /**\r\n     * Sets the text data associated with an ENS node and key.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param key The key to set.\r\n     * @param value The text data value to set.\r\n     */\r\n    function setText(bytes32 node, string calldata key, string calldata value) external authorised(node) {\r\n        texts[node][key] = value;\r\n        emit TextChanged(node, key, key);\r\n    }\r\n\r\n    /**\r\n     * Returns the text data associated with an ENS node and key.\r\n     * @param node The ENS node to query.\r\n     * @param key The text data key to query.\r\n     * @return The associated text data.\r\n     */\r\n    function text(bytes32 node, string calldata key) external view returns (string memory) {\r\n        return texts[node][key];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\r\n        return interfaceID == TEXT_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/ResolverBase.sol": {
      "content": "pragma solidity >=0.8.4;\r\nabstract contract ResolverBase {\r\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\r\n\r\n    function supportsInterface(bytes4 interfaceID) virtual public pure returns(bool) {\r\n        return interfaceID == INTERFACE_META_ID;\r\n    }\r\n\r\n    function isAuthorised(bytes32 node) internal virtual view returns(bool);\r\n\r\n    modifier authorised(bytes32 node) {\r\n        require(isAuthorised(node));\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/RRUtils.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"./BytesUtils.sol\";\r\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\r\n\r\n/**\r\n* @dev RRUtils is a library that provides utilities for parsing DNS resource records.\r\n*/\r\nlibrary RRUtils {\r\n    using BytesUtils for *;\r\n    using Buffer for *;\r\n\r\n    /**\r\n    * @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\r\n    * @param self The byte array to read a name from.\r\n    * @param offset The offset to start reading at.\r\n    * @return The length of the DNS name at 'offset', in bytes.\r\n    */\r\n    function nameLength(bytes memory self, uint offset) internal pure returns(uint) {\r\n        uint idx = offset;\r\n        while (true) {\r\n            assert(idx < self.length);\r\n            uint labelLen = self.readUint8(idx);\r\n            idx += labelLen + 1;\r\n            if (labelLen == 0) {\r\n                break;\r\n            }\r\n        }\r\n        return idx - offset;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns a DNS format name at the specified offset of self.\r\n    * @param self The byte array to read a name from.\r\n    * @param offset The offset to start reading at.\r\n    * @return ret The name.\r\n    */\r\n    function readName(bytes memory self, uint offset) internal pure returns(bytes memory ret) {\r\n        uint len = nameLength(self, offset);\r\n        return self.substring(offset, len);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\r\n    * @param self The byte array to read a name from.\r\n    * @param offset The offset to start reading at.\r\n    * @return The number of labels in the DNS name at 'offset', in bytes.\r\n    */\r\n    function labelCount(bytes memory self, uint offset) internal pure returns(uint) {\r\n        uint count = 0;\r\n        while (true) {\r\n            assert(offset < self.length);\r\n            uint labelLen = self.readUint8(offset);\r\n            offset += labelLen + 1;\r\n            if (labelLen == 0) {\r\n                break;\r\n            }\r\n            count += 1;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    uint constant RRSIG_TYPE = 0;\r\n    uint constant RRSIG_ALGORITHM = 2;\r\n    uint constant RRSIG_LABELS = 3;\r\n    uint constant RRSIG_TTL = 4;\r\n    uint constant RRSIG_EXPIRATION = 8;\r\n    uint constant RRSIG_INCEPTION = 12;\r\n    uint constant RRSIG_KEY_TAG = 16;\r\n    uint constant RRSIG_SIGNER_NAME = 18;\r\n\r\n    struct SignedSet {\r\n        uint16 typeCovered;\r\n        uint8 algorithm;\r\n        uint8 labels;\r\n        uint32 ttl;\r\n        uint32 expiration;\r\n        uint32 inception;\r\n        uint16 keytag;\r\n        bytes signerName;\r\n        bytes data;\r\n        bytes name;\r\n    }\r\n\r\n    function readSignedSet(bytes memory data) internal pure returns(SignedSet memory self) {\r\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\r\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\r\n        self.labels = data.readUint8(RRSIG_LABELS);\r\n        self.ttl = data.readUint32(RRSIG_TTL);\r\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\r\n        self.inception = data.readUint32(RRSIG_INCEPTION);\r\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\r\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\r\n        self.data = data.substring(RRSIG_SIGNER_NAME + self.signerName.length, data.length - RRSIG_SIGNER_NAME - self.signerName.length);\r\n    }\r\n\r\n    function rrs(SignedSet memory rrset) internal pure returns(RRIterator memory) {\r\n        return iterateRRs(rrset.data, 0);\r\n    }\r\n\r\n    /**\r\n    * @dev An iterator over resource records.\r\n    */\r\n    struct RRIterator {\r\n        bytes data;\r\n        uint offset;\r\n        uint16 dnstype;\r\n        uint16 class;\r\n        uint32 ttl;\r\n        uint rdataOffset;\r\n        uint nextOffset;\r\n    }\r\n\r\n    /**\r\n    * @dev Begins iterating over resource records.\r\n    * @param self The byte string to read from.\r\n    * @param offset The offset to start reading at.\r\n    * @return ret An iterator object.\r\n    */\r\n    function iterateRRs(bytes memory self, uint offset) internal pure returns (RRIterator memory ret) {\r\n        ret.data = self;\r\n        ret.nextOffset = offset;\r\n        next(ret);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns true iff there are more RRs to iterate.\r\n    * @param iter The iterator to check.\r\n    * @return True iff the iterator has finished.\r\n    */\r\n    function done(RRIterator memory iter) internal pure returns(bool) {\r\n        return iter.offset >= iter.data.length;\r\n    }\r\n\r\n    /**\r\n    * @dev Moves the iterator to the next resource record.\r\n    * @param iter The iterator to advance.\r\n    */\r\n    function next(RRIterator memory iter) internal pure {\r\n        iter.offset = iter.nextOffset;\r\n        if (iter.offset >= iter.data.length) {\r\n            return;\r\n        }\r\n\r\n        // Skip the name\r\n        uint off = iter.offset + nameLength(iter.data, iter.offset);\r\n\r\n        // Read type, class, and ttl\r\n        iter.dnstype = iter.data.readUint16(off);\r\n        off += 2;\r\n        iter.class = iter.data.readUint16(off);\r\n        off += 2;\r\n        iter.ttl = iter.data.readUint32(off);\r\n        off += 4;\r\n\r\n        // Read the rdata\r\n        uint rdataLength = iter.data.readUint16(off);\r\n        off += 2;\r\n        iter.rdataOffset = off;\r\n        iter.nextOffset = off + rdataLength;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the name of the current record.\r\n    * @param iter The iterator.\r\n    * @return A new bytes object containing the owner name from the RR.\r\n    */\r\n    function name(RRIterator memory iter) internal pure returns(bytes memory) {\r\n        return iter.data.substring(iter.offset, nameLength(iter.data, iter.offset));\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the rdata portion of the current record.\r\n    * @param iter The iterator.\r\n    * @return A new bytes object containing the RR's RDATA.\r\n    */\r\n    function rdata(RRIterator memory iter) internal pure returns(bytes memory) {\r\n        return iter.data.substring(iter.rdataOffset, iter.nextOffset - iter.rdataOffset);\r\n    }\r\n\r\n    uint constant DNSKEY_FLAGS = 0;\r\n    uint constant DNSKEY_PROTOCOL = 2;\r\n    uint constant DNSKEY_ALGORITHM = 3;\r\n    uint constant DNSKEY_PUBKEY = 4;\r\n\r\n    struct DNSKEY {\r\n        uint16 flags;\r\n        uint8 protocol;\r\n        uint8 algorithm;\r\n        bytes publicKey;\r\n    }\r\n\r\n    function readDNSKEY(bytes memory data, uint offset, uint length) internal pure returns(DNSKEY memory self) {\r\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\r\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\r\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\r\n        self.publicKey = data.substring(offset + DNSKEY_PUBKEY, length - DNSKEY_PUBKEY);\r\n    } \r\n\r\n    uint constant DS_KEY_TAG = 0;\r\n    uint constant DS_ALGORITHM = 2;\r\n    uint constant DS_DIGEST_TYPE = 3;\r\n    uint constant DS_DIGEST = 4;\r\n\r\n    struct DS {\r\n        uint16 keytag;\r\n        uint8 algorithm;\r\n        uint8 digestType;\r\n        bytes digest;\r\n    }\r\n\r\n    function readDS(bytes memory data, uint offset, uint length) internal pure returns(DS memory self) {\r\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\r\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\r\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\r\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\r\n    }\r\n\r\n    struct NSEC3 {\r\n        uint8 hashAlgorithm;\r\n        uint8 flags;\r\n        uint16 iterations;\r\n        bytes salt;\r\n        bytes32 nextHashedOwnerName;\r\n        bytes typeBitmap;\r\n    }\r\n\r\n    uint constant NSEC3_HASH_ALGORITHM = 0;\r\n    uint constant NSEC3_FLAGS = 1;\r\n    uint constant NSEC3_ITERATIONS = 2;\r\n    uint constant NSEC3_SALT_LENGTH = 4;\r\n    uint constant NSEC3_SALT = 5;\r\n\r\n    function readNSEC3(bytes memory data, uint offset, uint length) internal pure returns(NSEC3 memory self) {\r\n        uint end = offset + length;\r\n        self.hashAlgorithm = data.readUint8(offset + NSEC3_HASH_ALGORITHM);\r\n        self.flags = data.readUint8(offset + NSEC3_FLAGS);\r\n        self.iterations = data.readUint16(offset + NSEC3_ITERATIONS);\r\n        uint8 saltLength = data.readUint8(offset + NSEC3_SALT_LENGTH);\r\n        offset = offset + NSEC3_SALT;\r\n        self.salt = data.substring(offset, saltLength);\r\n        offset += saltLength;\r\n        uint8 nextLength = data.readUint8(offset);\r\n        require(nextLength <= 32);\r\n        offset += 1;\r\n        self.nextHashedOwnerName = data.readBytesN(offset, nextLength);\r\n        offset += nextLength;\r\n        self.typeBitmap = data.substring(offset, end - offset);\r\n    }\r\n\r\n    function checkTypeBitmap(NSEC3 memory self, uint16 rrtype) internal pure returns(bool) {\r\n        return checkTypeBitmap(self.typeBitmap, 0, rrtype);\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if a given RR type exists in a type bitmap.\r\n    * @param bitmap The byte string to read the type bitmap from.\r\n    * @param offset The offset to start reading at.\r\n    * @param rrtype The RR type to check for.\r\n    * @return True if the type is found in the bitmap, false otherwise.\r\n    */\r\n    function checkTypeBitmap(bytes memory bitmap, uint offset, uint16 rrtype) internal pure returns (bool) {\r\n        uint8 typeWindow = uint8(rrtype >> 8);\r\n        uint8 windowByte = uint8((rrtype & 0xff) / 8);\r\n        uint8 windowBitmask = uint8(uint8(1) << (uint8(7) - uint8(rrtype & 0x7)));\r\n        for (uint off = offset; off < bitmap.length;) {\r\n            uint8 window = bitmap.readUint8(off);\r\n            uint8 len = bitmap.readUint8(off + 1);\r\n            if (typeWindow < window) {\r\n                // We've gone past our window; it's not here.\r\n                return false;\r\n            } else if (typeWindow == window) {\r\n                // Check this type bitmap\r\n                if (len <= windowByte) {\r\n                    // Our type is past the end of the bitmap\r\n                    return false;\r\n                }\r\n                return (bitmap.readUint8(off + windowByte + 2) & windowBitmask) != 0;\r\n            } else {\r\n                // Skip this type bitmap\r\n                off += len + 2;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function compareNames(bytes memory self, bytes memory other) internal pure returns (int) {\r\n        if (self.equals(other)) {\r\n            return 0;\r\n        }\r\n\r\n        uint off;\r\n        uint otheroff;\r\n        uint prevoff;\r\n        uint otherprevoff;\r\n        uint counts = labelCount(self, 0);\r\n        uint othercounts = labelCount(other, 0);\r\n\r\n        // Keep removing labels from the front of the name until both names are equal length\r\n        while (counts > othercounts) {\r\n            prevoff = off;\r\n            off = progress(self, off);\r\n            counts--;\r\n        }\r\n\r\n        while (othercounts > counts) {\r\n            otherprevoff = otheroff;\r\n            otheroff = progress(other, otheroff);\r\n            othercounts--;\r\n        }\r\n\r\n        // Compare the last nonequal labels to each other\r\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\r\n            prevoff = off;\r\n            off = progress(self, off);\r\n            otherprevoff = otheroff;\r\n            otheroff = progress(other, otheroff);\r\n            counts -= 1;\r\n        }\r\n\r\n        if (off == 0) {\r\n            return -1;\r\n        }\r\n        if(otheroff == 0) {\r\n            return 1;\r\n        }\r\n\r\n        return self.compare(prevoff + 1, self.readUint8(prevoff), other, otherprevoff + 1, other.readUint8(otherprevoff));\r\n    }\r\n\r\n    /**\r\n     * @dev Compares two serial numbers using RFC1982 serial number math.\r\n     */\r\n    function serialNumberGte(uint32 i1, uint32 i2) internal pure returns(bool) {\r\n        return int32(i1) - int32(i2) >= 0;\r\n    }\r\n\r\n    function progress(bytes memory body, uint off) internal pure returns(uint) {\r\n        return off + 1 + body.readUint8(off);\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the keytag for a chunk of data.\r\n     * @param data The data to compute a keytag for.\r\n     * @return The computed key tag.\r\n     */\r\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\r\n        /* This function probably deserves some explanation.\r\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\r\n         * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\r\n         *\r\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\r\n         *         uint ac;\r\n         *         for (uint i = 0; i < data.length; i++) {\r\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\r\n         *         }\r\n         *         return uint16(ac + (ac >> 16));\r\n         *     }\r\n         *\r\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\r\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM's\r\n         * large words work in our favour.\r\n         *\r\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\r\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\r\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we're\r\n         * effectively summing 16 different numbers with each EVM ADD opcode.\r\n         *\r\n         * Once it's added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\r\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\r\n         * After the first addition on both accumulators, there's enough room to add the two accumulators together,\r\n         * and the remaining sums can be done just on ac1.\r\n         */\r\n        unchecked {\r\n            require(data.length <= 8192, \"Long keys not permitted\");\r\n            uint ac1;\r\n            uint ac2;\r\n            for(uint i = 0; i < data.length + 31; i += 32) {\r\n                uint word;\r\n                assembly {\r\n                    word := mload(add(add(data, 32), i))\r\n                }\r\n                if(i + 32 > data.length) {\r\n                    uint unused = 256 - (data.length - i) * 8;\r\n                    word = (word >> unused) << unused;\r\n                }\r\n                ac1 += (word & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8;\r\n                ac2 += (word & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\r\n            }\r\n            ac1 = (ac1 & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\r\n                + ((ac1 & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16);\r\n            ac2 = (ac2 & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\r\n                + ((ac2 & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16);\r\n            ac1 = (ac1 << 8) + ac2;\r\n            ac1 = (ac1 & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\r\n                + ((ac1 & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32);\r\n            ac1 = (ac1 & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\r\n                + ((ac1 & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64);\r\n            ac1 = (ac1 & 0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                + (ac1 >> 128);\r\n            ac1 += (ac1 >> 16) & 0xFFFF;\r\n            return uint16(ac1);\r\n        }\r\n    }\r\n}"
    },
    "contracts/dnssec-oracle/BytesUtils.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nlibrary BytesUtils {\r\n    /*\r\n    * @dev Returns the keccak-256 hash of a byte range.\r\n    * @param self The byte string to hash.\r\n    * @param offset The position to start hashing at.\r\n    * @param len The number of bytes to hash.\r\n    * @return The hash of the byte range.\r\n    */\r\n    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {\r\n        require(offset + len <= self.length);\r\n        assembly {\r\n            ret := keccak256(add(add(self, 32), offset), len)\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n    * @dev Returns a positive number if `other` comes lexicographically after\r\n    *      `self`, a negative number if it comes before, or zero if the\r\n    *      contents of the two bytes are equal.\r\n    * @param self The first bytes to compare.\r\n    * @param other The second bytes to compare.\r\n    * @return The result of the comparison.\r\n    */\r\n    function compare(bytes memory self, bytes memory other) internal pure returns (int) {\r\n        return compare(self, 0, self.length, other, 0, other.length);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns a positive number if `other` comes lexicographically after\r\n    *      `self`, a negative number if it comes before, or zero if the\r\n    *      contents of the two bytes are equal. Comparison is done per-rune,\r\n    *      on unicode codepoints.\r\n    * @param self The first bytes to compare.\r\n    * @param offset The offset of self.\r\n    * @param len    The length of self.\r\n    * @param other The second bytes to compare.\r\n    * @param otheroffset The offset of the other string.\r\n    * @param otherlen    The length of the other string.\r\n    * @return The result of the comparison.\r\n    */\r\n    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {\r\n        uint shortest = len;\r\n        if (otherlen < len)\r\n        shortest = otherlen;\r\n\r\n        uint selfptr;\r\n        uint otherptr;\r\n\r\n        assembly {\r\n            selfptr := add(self, add(offset, 32))\r\n            otherptr := add(other, add(otheroffset, 32))\r\n        }\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint mask;\r\n                if (shortest > 32) {\r\n                    mask = type(uint256).max;\r\n                } else {\r\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                }\r\n                int diff = int(a & mask) - int(b & mask);\r\n                if (diff != 0)\r\n                return diff;\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n\r\n        return int(len) - int(otherlen);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the two byte ranges are equal.\r\n    * @param self The first byte range to compare.\r\n    * @param offset The offset into the first byte range.\r\n    * @param other The second byte range to compare.\r\n    * @param otherOffset The offset into the second byte range.\r\n    * @param len The number of bytes to compare\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {\r\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the two byte ranges are equal with offsets.\r\n    * @param self The first byte range to compare.\r\n    * @param offset The offset into the first byte range.\r\n    * @param other The second byte range to compare.\r\n    * @param otherOffset The offset into the second byte range.\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {\r\n        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\r\n    }\r\n\r\n    /*\r\n    * @dev Compares a range of 'self' to all of 'other' and returns True iff\r\n    *      they are equal.\r\n    * @param self The first byte range to compare.\r\n    * @param offset The offset into the first byte range.\r\n    * @param other The second byte range to compare.\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {\r\n        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the two byte ranges are equal.\r\n    * @param self The first byte range to compare.\r\n    * @param other The second byte range to compare.\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {\r\n        return self.length == other.length && equals(self, 0, other, 0, self.length);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 8-bit number at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 8 bits of the string, interpreted as an integer.\r\n    */\r\n    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {\r\n        return uint8(self[idx]);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 16-bit number at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 16 bits of the string, interpreted as an integer.\r\n    */\r\n    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {\r\n        require(idx + 2 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 32-bit number at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 32 bits of the string, interpreted as an integer.\r\n    */\r\n    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {\r\n        require(idx + 4 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 32 byte value at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 32 bytes of the string.\r\n    */\r\n    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {\r\n        require(idx + 32 <= self.length);\r\n        assembly {\r\n            ret := mload(add(add(self, 32), idx))\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 32 byte value at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 32 bytes of the string.\r\n    */\r\n    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {\r\n        require(idx + 20 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the n byte value at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes.\r\n    * @param len The number of bytes.\r\n    * @return The specified 32 bytes of the string.\r\n    */\r\n    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {\r\n        require(len <= 32);\r\n        require(idx + len <= self.length);\r\n        assembly {\r\n            let mask := not(sub(exp(256, sub(32, len)), 1))\r\n            ret := and(mload(add(add(self, 32), idx)),  mask)\r\n        }\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        unchecked {\r\n            uint mask = (256 ** (32 - len)) - 1;\r\n            assembly {\r\n                let srcpart := and(mload(src), not(mask))\r\n                let destpart := and(mload(dest), mask)\r\n                mstore(dest, or(destpart, srcpart))\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Copies a substring into a new byte string.\r\n    * @param self The byte string to copy from.\r\n    * @param offset The offset to start copying at.\r\n    * @param len The number of bytes to copy.\r\n    */\r\n    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {\r\n        require(offset + len <= self.length);\r\n\r\n        bytes memory ret = new bytes(len);\r\n        uint dest;\r\n        uint src;\r\n\r\n        assembly {\r\n            dest := add(ret, 32)\r\n            src := add(add(self, 32), offset)\r\n        }\r\n        memcpy(dest, src, len);\r\n\r\n        return ret;\r\n    }\r\n\r\n    // Maps characters from 0x30 to 0x7A to their base32 values.\r\n    // 0xFF represents invalid characters in that range.\r\n    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';\r\n\r\n    /**\r\n     * @dev Decodes unpadded base32 data of up to one word in length.\r\n     * @param self The data to decode.\r\n     * @param off Offset into the string to start at.\r\n     * @param len Number of characters to decode.\r\n     * @return The decoded data, left aligned.\r\n     */\r\n    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {\r\n        require(len <= 52);\r\n\r\n        uint ret = 0;\r\n        uint8 decoded;\r\n        for(uint i = 0; i < len; i++) {\r\n            bytes1 char = self[off + i];\r\n            require(char >= 0x30 && char <= 0x7A);\r\n            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);\r\n            require(decoded <= 0x20);\r\n            if(i == len - 1) {\r\n                break;\r\n            }\r\n            ret = (ret << 5) | decoded;\r\n        }\r\n\r\n        uint bitlen = len * 5;\r\n        if(len % 8 == 0) {\r\n            // Multiple of 8 characters, no padding\r\n            ret = (ret << 5) | decoded;\r\n        } else if(len % 8 == 2) {\r\n            // Two extra characters - 1 byte\r\n            ret = (ret << 3) | (decoded >> 2);\r\n            bitlen -= 2;\r\n        } else if(len % 8 == 4) {\r\n            // Four extra characters - 2 bytes\r\n            ret = (ret << 1) | (decoded >> 4);\r\n            bitlen -= 4;\r\n        } else if(len % 8 == 5) {\r\n            // Five extra characters - 3 bytes\r\n            ret = (ret << 4) | (decoded >> 1);\r\n            bitlen -= 1;\r\n        } else if(len % 8 == 7) {\r\n            // Seven extra characters - 4 bytes\r\n            ret = (ret << 2) | (decoded >> 3);\r\n            bitlen -= 3;\r\n        } else {\r\n            revert();\r\n        }\r\n\r\n        return bytes32(ret << (256 - bitlen));\r\n    }\r\n}"
    },
    "@ensdomains/buffer/contracts/Buffer.sol": {
      "content": "pragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for writing to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(32, add(ptr, capacity)))\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint a, uint b) private pure returns(uint) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The start offset to write to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, len);\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, data.length);\n    }\n\n    /**\n    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The offset to write the byte at.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\n        if (off >= buf.capacity) {\n            resize(buf, buf.capacity * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if eq(off, buflen) {\n                mstore(bufptr, add(buflen, 1))\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        return writeUint8(buf, buf.buf.length, data);\n    }\n\n    /**\n    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The offset to write at.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + off + len\n                let dest := add(add(bufptr, off), len)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(add(off, len), mload(bufptr)) {\n                    mstore(bufptr, add(off, len))\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The offset to write at.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\n        return write(buf, off, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, 32);\n    }\n\n    /**\n    * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The offset to write at.\n    * @param data The data to append.\n    * @param len The number of bytes to write (right-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + off + sizeof(buffer length) + len\n            let dest := add(add(bufptr, off), len)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(add(off, len), mload(bufptr)) {\n                mstore(bufptr, add(off, len))\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     * exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        return writeInt(buf, buf.buf.length, data, len);\n    }\n}\n"
    },
    "contracts/resolvers/OwnedResolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./profiles/ABIResolver.sol\";\r\nimport \"./profiles/AddrResolver.sol\";\r\nimport \"./profiles/ContentHashResolver.sol\";\r\nimport \"./profiles/DNSResolver.sol\";\r\nimport \"./profiles/InterfaceResolver.sol\";\r\nimport \"./profiles/NameResolver.sol\";\r\nimport \"./profiles/PubkeyResolver.sol\";\r\nimport \"./profiles/TextResolver.sol\";\r\n\r\n/**\r\n * A simple resolver anyone can use; only allows the owner of a node to set its\r\n * address.\r\n */\r\ncontract OwnedResolver is Ownable, ABIResolver, AddrResolver, ContentHashResolver, DNSResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver {\r\n    function isAuthorised(bytes32 node) internal override view returns(bool) {\r\n        return msg.sender == owner();\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) virtual override(ABIResolver, AddrResolver, ContentHashResolver, DNSResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver) public pure returns(bool) {\r\n        return super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/dnsregistrar/DNSRegistrar.sol": {
      "content": "pragma solidity ^0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../dnssec-oracle/BytesUtils.sol\";\r\nimport \"../dnssec-oracle/DNSSEC.sol\";\r\nimport \"../registry/ENSRegistry.sol\";\r\nimport \"../root/Root.sol\";\r\nimport \"./DNSClaimChecker.sol\";\r\nimport \"./PublicSuffixList.sol\";\r\nimport \"../resolvers/profiles/AddrResolver.sol\";\r\n\r\ninterface IDNSRegistrar {\r\n    function claim(bytes memory name, bytes memory proof) external;\r\n    function proveAndClaim(bytes memory name, DNSSEC.RRSetWithSignature[] memory input, bytes memory proof) external;\r\n    function proveAndClaimWithResolver(bytes memory name, DNSSEC.RRSetWithSignature[] memory input, bytes memory proof, address resolver, address addr) external;\r\n}\r\n\r\n/**\r\n * @dev An ENS registrar that allows the owner of a DNS name to claim the\r\n *      corresponding name in ENS.\r\n */\r\ncontract DNSRegistrar is IDNSRegistrar {\r\n    using BytesUtils for bytes;\r\n\r\n    DNSSEC public oracle;\r\n    ENS public ens;\r\n    PublicSuffixList public suffixes;\r\n\r\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n\r\n    event Claim(bytes32 indexed node, address indexed owner, bytes dnsname);\r\n    event NewOracle(address oracle);\r\n    event NewPublicSuffixList(address suffixes);\r\n\r\n    constructor(DNSSEC _dnssec, PublicSuffixList _suffixes, ENS _ens) {\r\n        oracle = _dnssec;\r\n        emit NewOracle(address(oracle));\r\n        suffixes = _suffixes;\r\n        emit NewPublicSuffixList(address(suffixes));\r\n        ens = _ens;\r\n    }\r\n\r\n    /**\r\n     * @dev This contract's owner-only functions can be invoked by the owner of the ENS root.\r\n     */\r\n    modifier onlyOwner {\r\n        Root root = Root(ens.owner(bytes32(0)));\r\n        address owner = root.owner();\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setOracle(DNSSEC _dnssec) public onlyOwner {\r\n        oracle = _dnssec;\r\n        emit NewOracle(address(oracle));\r\n    }\r\n\r\n    function setPublicSuffixList(PublicSuffixList _suffixes) public onlyOwner {\r\n        suffixes = _suffixes;\r\n        emit NewPublicSuffixList(address(suffixes));\r\n    }\r\n\r\n    /**\r\n     * @dev Claims a name by proving ownership of its DNS equivalent.\r\n     * @param name The name to claim, in DNS wire format.\r\n     * @param proof A DNS RRSet proving ownership of the name. Must be verified\r\n     *        in the DNSSEC oracle before calling. This RRSET must contain a TXT\r\n     *        record for '_ens.' + name, with the value 'a=0x...'. Ownership of\r\n     *        the name will be transferred to the address specified in the TXT\r\n     *        record.\r\n     */\r\n    function claim(bytes memory name, bytes memory proof) public override {\r\n        (bytes32 rootNode, bytes32 labelHash, address addr) = _claim(name, proof);\r\n        ens.setSubnodeOwner(rootNode, labelHash, addr);\r\n    }\r\n\r\n    /**\r\n     * @dev Submits proofs to the DNSSEC oracle, then claims a name using those proofs.\r\n     * @param name The name to claim, in DNS wire format.\r\n     * @param input The data to be passed to the Oracle's `submitProofs` function. The last\r\n     *        proof must be the TXT record required by the registrar.\r\n     * @param proof The proof record for the first element in input.\r\n     */\r\n    function proveAndClaim(bytes memory name, DNSSEC.RRSetWithSignature[] memory input, bytes memory proof) public override {\r\n        proof = oracle.submitRRSets(input, proof);\r\n        claim(name, proof);\r\n    }\r\n\r\n    function proveAndClaimWithResolver(bytes memory name, DNSSEC.RRSetWithSignature[] memory input, bytes memory proof, address resolver, address addr) public override {\r\n        proof = oracle.submitRRSets(input, proof);\r\n        (bytes32 rootNode, bytes32 labelHash, address owner) = _claim(name, proof);\r\n        require(msg.sender == owner, \"Only owner can call proveAndClaimWithResolver\");\r\n        if(addr != address(0)) {\r\n            require(resolver != address(0), \"Cannot set addr if resolver is not set\");\r\n            // Set ourselves as the owner so we can set a record on the resolver\r\n            ens.setSubnodeRecord(rootNode, labelHash, address(this), resolver, 0);\r\n            bytes32 node = keccak256(abi.encodePacked(rootNode, labelHash));\r\n            // Set the resolver record\r\n            AddrResolver(resolver).setAddr(node, addr);\r\n            // Transfer the record to the owner\r\n            ens.setOwner(node, owner);\r\n        } else {\r\n            ens.setSubnodeRecord(rootNode, labelHash, owner, resolver, 0);\r\n        }\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\r\n        return interfaceID == INTERFACE_META_ID ||\r\n               interfaceID == type(IDNSRegistrar).interfaceId;\r\n    }\r\n\r\n    function _claim(bytes memory name, bytes memory proof) internal returns(bytes32 rootNode, bytes32 labelHash, address addr) {\r\n        // Get the first label\r\n        uint labelLen = name.readUint8(0);\r\n        labelHash = name.keccak(1, labelLen);\r\n\r\n        // Parent name must be in the public suffix list.\r\n        bytes memory parentName = name.substring(labelLen + 1, name.length - labelLen - 1);\r\n        require(suffixes.isPublicSuffix(parentName), \"Parent name must be a public suffix\");\r\n\r\n        // Make sure the parent name is enabled\r\n        rootNode = enableNode(parentName, 0);\r\n\r\n        (addr,) = DNSClaimChecker.getOwnerAddress(oracle, name, proof);\r\n\r\n        emit Claim(keccak256(abi.encodePacked(rootNode, labelHash)), addr, name);\r\n    }\r\n\r\n    function enableNode(bytes memory domain, uint offset) internal returns(bytes32 node) {\r\n        uint len = domain.readUint8(offset);\r\n        if(len == 0) {\r\n            return bytes32(0);\r\n        }\r\n\r\n        bytes32 parentNode = enableNode(domain, offset + len + 1);\r\n        bytes32 label = domain.keccak(offset + 1, len);\r\n        node = keccak256(abi.encodePacked(parentNode, label));\r\n        address owner = ens.owner(node);\r\n        require(owner == address(0) || owner == address(this), \"Cannot enable a name owned by someone else\");\r\n        if(owner != address(this)) {\r\n            if(parentNode == bytes32(0)) {\r\n                Root root = Root(ens.owner(bytes32(0)));\r\n                root.setSubnodeOwner(label, address(this));\r\n            } else {\r\n                ens.setSubnodeOwner(parentNode, label, address(this));\r\n            }\r\n        }\r\n        return node;\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/DNSSEC.sol": {
      "content": "pragma solidity ^0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\nabstract contract DNSSEC {\r\n\r\n    bytes public anchors;\r\n\r\n    struct RRSetWithSignature {\r\n        bytes rrset;\r\n        bytes sig;\r\n    }\r\n\r\n    event AlgorithmUpdated(uint8 id, address addr);\r\n    event DigestUpdated(uint8 id, address addr);\r\n    event NSEC3DigestUpdated(uint8 id, address addr);\r\n    event RRSetUpdated(bytes name, bytes rrset);\r\n\r\n    function submitRRSets(RRSetWithSignature[] memory input, bytes calldata proof) public virtual returns (bytes memory);\r\n    function submitRRSet(RRSetWithSignature calldata input, bytes calldata proof) public virtual returns (bytes memory);\r\n    function deleteRRSet(uint16 deleteType, bytes calldata deleteName, RRSetWithSignature calldata nsec, bytes calldata proof) public virtual;\r\n    function deleteRRSetNSEC3(uint16 deleteType, bytes memory deleteName, RRSetWithSignature memory closestEncloser, RRSetWithSignature memory nextClosest, bytes memory dnskey) public virtual;\r\n    function rrdata(uint16 dnstype, bytes calldata name) external virtual view returns (uint32, uint32, bytes20);\r\n}\r\n"
    },
    "contracts/registry/ENSRegistry.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nimport \"./ENS.sol\";\r\nimport \"../decentraname/IDecentraNameController.sol\";\r\n\r\n/**\r\n * The ENS registry contract.\r\n */\r\ncontract ENSRegistry is ENS {\r\n\r\n    struct Record {\r\n        address resolver;\r\n        uint64 ttl;\r\n    }\r\n\r\n    mapping (bytes32 => Record) records;\r\n    mapping (address => mapping(address => bool)) operators;\r\n\r\n    // The dweb NFT token\r\n    IDecentraNameController public decentraNameController;\r\n\r\n    // Permits modifications only by the owner of the specified node.\r\n    modifier authorised(bytes32 node) {\r\n        address owner = decentraNameController.ownerOf(uint256(node));\r\n        require(owner == msg.sender || operators[owner][msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructs a new ENS registrar.\r\n     */\r\n    constructor(IDecentraNameController _decentraNameController) public {\r\n        decentraNameController = _decentraNameController;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the record for a node.\r\n     * @param node The node to update.\r\n     * @param owner The address of the new owner.\r\n     * @param resolver The address of the resolver.\r\n     * @param ttl The TTL in seconds.\r\n     */\r\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual override {\r\n        setOwner(node, owner);\r\n        _setResolverAndTTL(node, resolver, ttl);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the record for a subnode.\r\n     * @param node The parent node.\r\n     * @param label The hash of the label specifying the subnode.\r\n     * @param owner The address of the new owner.\r\n     * @param resolver The address of the resolver.\r\n     * @param ttl The TTL in seconds.\r\n     */\r\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual override {\r\n        bytes32 subnode = setSubnodeOwner(node, label, owner);\r\n        _setResolverAndTTL(subnode, resolver, ttl);\r\n    }\r\n\r\n    /**\r\n     * @dev Create subdomain and sets the record for a subnode.\r\n     * @param node The parent node.\r\n     * @param label The hash of the label specifying the subnode.\r\n     * @param owner The address of the new owner.\r\n     * @param resolver The address of the resolver.\r\n     * @param ttl The TTL in seconds.\r\n     */\r\n    function createSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual override {\r\n        // TODO: revisit for modifier\r\n        bytes32 subnode = createSubnode(node, label, owner);\r\n        _setResolverAndTTL(subnode, resolver, ttl);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\r\n     * @param node The node to transfer ownership of.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function setOwner(bytes32 node, address owner) public virtual override authorised(node) {\r\n        // TODO: revisit authorized node because msg.sender won't be owner if called from other contracts\r\n        _setOwner(node, owner);\r\n        emit Transfer(node, owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Create a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\r\n     * @param node The parent node.\r\n     * @param label The hash of the label specifying the subnode.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function createSubnode(bytes32 node, bytes32 label, address owner) public virtual override authorised(node) returns(bytes32) {\r\n        // TODO: revisit authorized node because msg.sender won't be owner if called from other contracts\r\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\r\n        _createNode(subnode, owner);\r\n        emit NewOwner(node, label, owner);\r\n        return subnode;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\r\n     * @param node The parent node.\r\n     * @param label The hash of the label specifying the subnode.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public virtual override authorised(node) returns(bytes32) {\r\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\r\n        _setOwner(subnode, owner);\r\n        emit NewOwner(node, label, owner);\r\n        return subnode;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the resolver address for the specified node.\r\n     * @param node The node to update.\r\n     * @param resolver The address of the resolver.\r\n     */\r\n    function setResolver(bytes32 node, address resolver) public virtual override authorised(node) {\r\n        emit NewResolver(node, resolver);\r\n        records[node].resolver = resolver;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the TTL for the specified node.\r\n     * @param node The node to update.\r\n     * @param ttl The TTL in seconds.\r\n     */\r\n    function setTTL(bytes32 node, uint64 ttl) public virtual override authorised(node) {\r\n        emit NewTTL(node, ttl);\r\n        records[node].ttl = ttl;\r\n    }\r\n\r\n    /**\r\n     * @dev Enable or disable approval for a third party (\"operator\") to manage\r\n     *  all of `msg.sender`'s ENS records. Emits the ApprovalForAll event.\r\n     * @param operator Address to add to the set of authorized operators.\r\n     * @param approved True if the operator is approved, false to revoke approval.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external virtual override {\r\n        operators[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that owns the specified node.\r\n     * @param node The specified node.\r\n     * @return address of the owner.\r\n     */\r\n    function owner(bytes32 node) public virtual override view returns (address) {\r\n        address addr = decentraNameController.ownerOf(uint256(node));\r\n        // TODO: what is the impact of below after all code changes?\r\n        if (addr == address(this)) {\r\n            return address(0x0);\r\n        }\r\n\r\n        return addr;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the resolver for the specified node.\r\n     * @param node The specified node.\r\n     * @return address of the resolver.\r\n     */\r\n    function resolver(bytes32 node) public virtual override view returns (address) {\r\n        return records[node].resolver;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the TTL of a node, and any records associated with it.\r\n     * @param node The specified node.\r\n     * @return ttl of the node.\r\n     */\r\n    function ttl(bytes32 node) public virtual override view returns (uint64) {\r\n        return records[node].ttl;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether a record has been imported to the registry.\r\n     * @param node The specified node.\r\n     * @return Bool if record exists\r\n     */\r\n    function recordExists(bytes32 node) public virtual override view returns (bool) {\r\n        return decentraNameController.existsToken(uint256(node));\r\n    }\r\n\r\n    /**\r\n     * @dev Query if an address is an authorized operator for another address.\r\n     * @param owner The address that owns the records.\r\n     * @param operator The address that acts on behalf of the owner.\r\n     * @return True if `operator` is an approved operator for `owner`, false otherwise.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external virtual override view returns (bool) {\r\n        return operators[owner][operator];\r\n    }\r\n\r\n    function _setOwner(bytes32 node, address owner) internal virtual {\r\n        decentraNameController.transferToken(owner, uint256(node));\r\n    }\r\n\r\n    function _createNode(bytes32 node, address owner) internal virtual {\r\n        decentraNameController.mintToken(owner, uint256(node));\r\n    }\r\n\r\n    function _setResolverAndTTL(bytes32 node, address resolver, uint64 ttl) internal {\r\n        if(resolver != records[node].resolver) {\r\n            records[node].resolver = resolver;\r\n            emit NewResolver(node, resolver);\r\n        }\r\n\r\n        if(ttl != records[node].ttl) {\r\n            records[node].ttl = ttl;\r\n            emit NewTTL(node, ttl);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/dnsregistrar/DNSClaimChecker.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"../dnssec-oracle/DNSSEC.sol\";\r\nimport \"../dnssec-oracle/BytesUtils.sol\";\r\nimport \"../dnssec-oracle/RRUtils.sol\";\r\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\r\n\r\nlibrary DNSClaimChecker {\r\n\r\n    using BytesUtils for bytes;\r\n    using RRUtils for *;\r\n    using Buffer for Buffer.buffer;\r\n\r\n    uint16 constant CLASS_INET = 1;\r\n    uint16 constant TYPE_TXT = 16;\r\n\r\n    function getOwnerAddress(DNSSEC oracle, bytes memory name, bytes memory proof)\r\n        internal\r\n        view\r\n        returns (address, bool)\r\n    {\r\n        // Add \"_ens.\" to the front of the name.\r\n        Buffer.buffer memory buf;\r\n        buf.init(name.length + 5);\r\n        buf.append(\"\\x04_ens\");\r\n        buf.append(name);\r\n        bytes20 hash;\r\n        uint32 expiration;\r\n        // Check the provided TXT record has been validated by the oracle\r\n        (, expiration, hash) = oracle.rrdata(TYPE_TXT, buf.buf);\r\n        if (hash == bytes20(0) && proof.length == 0) return (address(0x0), false);\r\n\r\n        require(hash == bytes20(keccak256(proof)));\r\n\r\n        for (RRUtils.RRIterator memory iter = proof.iterateRRs(0); !iter.done(); iter.next()) {\r\n            require(RRUtils.serialNumberGte(expiration + iter.ttl, uint32(block.timestamp)), \"DNS record is stale; refresh or delete it before proceeding.\");\r\n\r\n            bool found;\r\n            address addr;\r\n            (addr, found) = parseRR(proof, iter.rdataOffset);\r\n            if (found) {\r\n                return (addr, true);\r\n            }\r\n        }\r\n\r\n        return (address(0x0), false);\r\n    }\r\n\r\n    function parseRR(bytes memory rdata, uint idx) internal pure returns (address, bool) {\r\n        while (idx < rdata.length) {\r\n            uint len = rdata.readUint8(idx); idx += 1;\r\n\r\n            bool found;\r\n            address addr;\r\n            (addr, found) = parseString(rdata, idx, len);\r\n\r\n            if (found) return (addr, true);\r\n            idx += len;\r\n        }\r\n\r\n        return (address(0x0), false);\r\n    }\r\n\r\n    function parseString(bytes memory str, uint idx, uint len) internal pure returns (address, bool) {\r\n        // TODO: More robust parsing that handles whitespace and multiple key/value pairs\r\n        if (str.readUint32(idx) != 0x613d3078) return (address(0x0), false); // 0x613d3078 == 'a=0x'\r\n        if (len < 44) return (address(0x0), false);\r\n        return hexToAddress(str, idx + 4);\r\n    }\r\n\r\n    function hexToAddress(bytes memory str, uint idx) internal pure returns (address, bool) {\r\n        if (str.length - idx < 40) return (address(0x0), false);\r\n        uint ret = 0;\r\n        for (uint i = idx; i < idx + 40; i++) {\r\n            ret <<= 4;\r\n            uint x = str.readUint8(i);\r\n            if (x >= 48 && x < 58) {\r\n                ret |= x - 48;\r\n            } else if (x >= 65 && x < 71) {\r\n                ret |= x - 55;\r\n            } else if (x >= 97 && x < 103) {\r\n                ret |= x - 87;\r\n            } else {\r\n                return (address(0x0), false);\r\n            }\r\n        }\r\n        return (address(uint160(ret)), true);\r\n    }\r\n}\r\n"
    },
    "contracts/dnsregistrar/PublicSuffixList.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\ninterface PublicSuffixList {\r\n    function isPublicSuffix(bytes calldata name) external view returns(bool);\r\n}\r\n"
    },
    "contracts/dnsregistrar/TLDPublicSuffixList.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"../dnssec-oracle/BytesUtils.sol\";\r\nimport \"./PublicSuffixList.sol\";\r\n\r\n/**\r\n * @dev A public suffix list that treats all TLDs as public suffixes.\r\n */\r\ncontract TLDPublicSuffixList is PublicSuffixList {\r\n    using BytesUtils for bytes;\r\n\r\n    function isPublicSuffix(bytes calldata name) external override view returns(bool) {\r\n        uint labellen = name.readUint8(0);\r\n        return labellen > 0 && name.readUint8(labellen + 1) == 0;\r\n    }\r\n}\r\n"
    },
    "test/dnssec-oracle/TestRRUtils.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"../../contracts/dnssec-oracle/RRUtils.sol\";\r\nimport \"../../contracts/dnssec-oracle/BytesUtils.sol\";\r\n\r\ncontract TestRRUtils {\r\n  using BytesUtils for *;\r\n  using RRUtils for *;\r\n\r\n  uint16 constant DNSTYPE_A = 1;\r\n  uint16 constant DNSTYPE_CNAME = 5;\r\n  uint16 constant DNSTYPE_MX = 15;\r\n  uint16 constant DNSTYPE_TEXT = 16;\r\n  uint16 constant DNSTYPE_RRSIG = 46;\r\n  uint16 constant DNSTYPE_NSEC = 47;\r\n  uint16 constant DNSTYPE_TYPE1234 = 1234;\r\n\r\n  function testNameLength() public pure {\r\n    require(hex'00'.nameLength(0) == 1, \"nameLength('.') == 1\");\r\n    require(hex'0361626300'.nameLength(4) == 1, \"nameLength('.') == 1\");\r\n    require(hex'0361626300'.nameLength(0) == 5, \"nameLength('abc.') == 5\");\r\n  }\r\n\r\n  function testLabelCount() public pure {\r\n    require(hex'00'.labelCount(0) == 0, \"labelCount('.') == 0\");\r\n    require(hex'016100'.labelCount(0) == 1, \"labelCount('a.') == 1\");\r\n    require(hex'016201610000'.labelCount(0) == 2, \"labelCount('b.a.') == 2\");\r\n    require(hex'066574686c61620378797a00'.labelCount(6 +1) == 1, \"nameLength('(bthlab).xyz.') == 6\");\r\n  }\r\n\r\n  function testIterateRRs() public pure {\r\n    // a. IN A 3600 127.0.0.1\r\n    // b.a. IN A 3600 192.168.1.1\r\n    bytes memory rrs = hex'0161000001000100000e1000047400000101620161000001000100000e100004c0a80101';\r\n    string[2] memory names = [hex'016100', hex'0162016100'];\r\n    string[2] memory rdatas = [hex'74000001', hex'c0a80101'];\r\n    uint i = 0;\r\n    for(RRUtils.RRIterator memory iter = rrs.iterateRRs(0); !iter.done(); iter.next()) {\r\n      require(uint(iter.dnstype) == 1, \"Type matches\");\r\n      require(uint(iter.class) == 1, \"Class matches\");\r\n      require(uint(iter.ttl) == 3600, \"TTL matches\");\r\n      require(keccak256(iter.name()) == keccak256(bytes(names[i])), \"Name matches\");\r\n      require(keccak256(iter.rdata()) == keccak256(bytes(rdatas[i])), \"Rdata matches\");\r\n      i++;\r\n    }\r\n    require(i == 2, \"Expected 2 records\");\r\n  }\r\n\r\n  function testCheckTypeBitmapTextType() public pure {\r\n    bytes memory tb = hex'0003000080';\r\n    require(tb.checkTypeBitmap(0, DNSTYPE_TEXT) == true, \"A record should exist in type bitmap\");\r\n  }\r\n\r\n  function testCheckTypeBitmap() public pure {\r\n    // From https://tools.ietf.org/html/rfc4034#section-4.3\r\n    //    alfa.example.com. 86400 IN NSEC host.example.com. (\r\n    //                               A MX RRSIG NSEC TYPE1234\r\n    bytes memory tb = hex'FF0006400100000003041b000000000000000000000000000000000000000000000000000020';\r\n\r\n    // Exists in bitmap\r\n    require(tb.checkTypeBitmap(1, DNSTYPE_A) == true, \"A record should exist in type bitmap\");\r\n    // Does not exist, but in a window that is included\r\n    require(tb.checkTypeBitmap(1, DNSTYPE_CNAME) == false, \"CNAME record should not exist in type bitmap\");\r\n    // Does not exist, past the end of a window that is included\r\n    require(tb.checkTypeBitmap(1, 64) == false, \"Type 64 should not exist in type bitmap\");\r\n    // Does not exist, in a window that does not exist\r\n    require(tb.checkTypeBitmap(1, 769) == false, \"Type 769 should not exist in type bitmap\");\r\n    // Exists in a subsequent window\r\n    require(tb.checkTypeBitmap(1, DNSTYPE_TYPE1234) == true, \"Type 1234 should exist in type bitmap\");\r\n    // Does not exist, past the end of the bitmap windows\r\n    require(tb.checkTypeBitmap(1, 1281) == false, \"Type 1281 should not exist in type bitmap\");\r\n  }\r\n\r\n  // Canonical ordering https://tools.ietf.org/html/rfc4034#section-6.1\r\n  function testCompareNames() public pure {\r\n    bytes memory bthLabXyz = hex'066274686c61620378797a00';\r\n    bytes memory ethLabXyz = hex'066574686c61620378797a00';\r\n    bytes memory xyz = hex'0378797a00';\r\n    bytes memory a_b_c  = hex'01610162016300';\r\n    bytes memory b_b_c  = hex'01620162016300';\r\n    bytes memory c      = hex'016300';\r\n    bytes memory d      = hex'016400';\r\n    bytes memory a_d_c  = hex'01610164016300';\r\n    bytes memory b_a_c  = hex'01620161016300';\r\n    bytes memory ab_c_d = hex'0261620163016400';\r\n    bytes memory a_c_d  = hex'01610163016400';\r\n\r\n    require(hex'0301616100'.compareNames(hex'0302616200') <  0,  \"label lengths are correctly checked\");\r\n    require(a_b_c.compareNames(c)      >  0,  \"one name has a difference of >1 label to with the same root name\");\r\n    require(a_b_c.compareNames(d)      <  0, \"one name has a difference of >1 label to with different root name\");\r\n    require(a_b_c.compareNames(a_d_c)  <  0, \"two names start the same but have differences in later labels\");\r\n    require(a_b_c.compareNames(b_a_c)  >  0, \"the first label sorts later, but the first label sorts earlier\");\r\n    require(ab_c_d.compareNames(a_c_d) >  0, \"two names where the first label on one is a prefix of the first label on the other\");\r\n    require(a_b_c.compareNames(b_b_c)  <  0, \"two names where the first label on one is a prefix of the first label on the other\");\r\n    require(xyz.compareNames(ethLabXyz) < 0, \"xyz comes before ethLab.xyz\");\r\n    require(bthLabXyz.compareNames(ethLabXyz) < 0, \"bthLab.xyz comes before ethLab.xyz\");\r\n    require(bthLabXyz.compareNames(bthLabXyz) == 0, \"bthLab.xyz and bthLab.xyz are the same\");\r\n    require(ethLabXyz.compareNames(bthLabXyz) >  0, \"ethLab.xyz comes after bethLab.xyz\");\r\n    require(bthLabXyz.compareNames(xyz)       >  0, \"bthLab.xyz comes after xyz\");\r\n  }\r\n\r\n  function testSerialNumberGt() public pure {\r\n    require(RRUtils.serialNumberGte(1, 0), \"1 >= 0\");\r\n    require(!RRUtils.serialNumberGte(0, 1), \"!(0 <= 1)\");\r\n    require(RRUtils.serialNumberGte(0, 0xFFFFFFFF), \"0 >= 0xFFFFFFFF\");\r\n    require(!RRUtils.serialNumberGte(0xFFFFFFFF, 0), \"!(0 <= 0xFFFFFFFF)\");\r\n    require(RRUtils.serialNumberGte(0x11111111, 0xAAAAAAAA), \"0x11111111 >= 0xAAAAAAAA\");\r\n    require(RRUtils.serialNumberGte(1, 1), \"1 >= 1\");\r\n  }\r\n\r\n  function testKeyTag() public view {\r\n    require(hex'0101030803010001a80020a95566ba42e886bb804cda84e47ef56dbd7aec612615552cec906d2116d0ef207028c51554144dfeafe7c7cb8f005dd18234133ac0710a81182ce1fd14ad2283bc83435f9df2f6313251931a176df0da51e54f42e604860dfb359580250f559cc543c4ffd51cbe3de8cfd06719237f9fc47ee729da06835fa452e825e9a18ebc2ecbcf563474652c33cf56a9033bcdf5d973121797ec8089041b6e03a1b72d0a735b984e03687309332324f27c2dba85e9db15e83a0143382e974b0621c18e625ecec907577d9e7bade95241a81ebbe8a901d4d3276e40b114c0a2e6fc38d19c2e6aab02644b2813f575fc21601e0dee49cd9ee96a43103e524d62873d'.computeKeytag() == 19036, \"Invalid keytag\");\r\n    require(hex'010003050440000003ba2fa05a75e173bede89eb71831ab14035f2408ad09df4d8dc8f8f72e8f13506feaddf7b04cb14958b82966e3420562302c4002bc4fd088432e160519bb14dae82443850c1423e06085710b5caf070d46b7ba7e481414f6a5fe225fdca984c959091645d0cf1c9a1a313d7e7fb7ba60b967b71a65f8cef2c3768e11b081c8fcf'.computeKeytag() == 21693, \"Invalid keytag (2)\");\r\n    require(hex'0100030503010001bfa54c38d909fabb0f937d70d775ba0df4c0badb09707d995249406950407a621c794c68b186b15dbf8f9f9ea231e9f96414ccda4eceb50b17a9ac6c4bd4b95da04849e96ee791578b703bc9ae184fb1794bac792a0787f693a40f19f523ee6dbd3599dbaaa9a50437926ecf6438845d1d49448962524f2a1a7a36b3a0a1eca3'.computeKeytag() == 33630);\r\n    require(hex'0101030803010001acffb409bcc939f831f7a1e5ec88f7a59255ec53040be432027390a4ce896d6f9086f3c5e177fbfe118163aaec7af1462c47945944c4e2c026be5e98bbcded25978272e1e3e079c5094d573f0e83c92f02b32d3513b1550b826929c80dd0f92cac966d17769fd5867b647c3f38029abdc48152eb8f207159ecc5d232c7c1537c79f4b7ac28ff11682f21681bf6d6aba555032bf6f9f036beb2aaa5b3778d6eebfba6bf9ea191be4ab0caea759e2f773a1f9029c73ecb8d5735b9321db085f1b8e2d8038fe2941992548cee0d67dd4547e11dd63af9c9fc1c5466fb684cf009d7197c2cf79e792ab501e6a8a1ca519af2cb9b5f6367e94c0d47502451357be1b5'.computeKeytag() == 20326, \"Invalid keytag (3)\");\r\n  }\r\n}"
    },
    "test/dnssec-oracle/TestBytesUtils.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"../../contracts/dnssec-oracle/RRUtils.sol\";\r\nimport \"../../contracts/dnssec-oracle/BytesUtils.sol\";\r\n\r\ncontract TestBytesUtils {\r\n  using BytesUtils for *;\r\n\r\n  function testKeccak() public pure {\r\n    require(\"\".keccak(0, 0) == bytes32(0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470), \"Incorrect hash of empty string\");\r\n    require(\"foo\".keccak(0, 3) == bytes32(0x41b1a0649752af1b28b3dc29a1556eee781e4a4c3a1f7f53f90fa834de098c4d), \"Incorrect hash of 'foo'\");\r\n    require(\"foo\".keccak(0, 0) == bytes32(0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470), \"Incorrect hash of empty string\");\r\n  }\r\n\r\n  function testEquals() public pure {\r\n    require(\"hello\".equals(\"hello\") == true, \"String equality\");\r\n    require(\"hello\".equals(\"goodbye\") == false, \"String inequality\");\r\n    require(\"hello\".equals(1, \"ello\") == true, \"Substring to string equality\");\r\n    require(\"hello\".equals(1, \"jello\", 1, 4) == true, \"Substring to substring equality\");\r\n    require(\"zhello\".equals(1, \"abchello\", 3) == true,   \"Compare different value with multiple length\");\r\n  }\r\n\r\n  function testComparePartial() public pure {\r\n    require(\"xax\".compare(1, 1, \"xxbxx\", 2, 1)   < 0 == true,  \"Compare same length\");\r\n    require(\"xax\".compare(1, 1, \"xxabxx\", 2, 2)  < 0 == true,  \"Compare different length\");\r\n    require(\"xax\".compare(1, 1, \"xxaxx\", 2, 1)  == 0 == true,  \"Compare same with different offset\");\r\n  }\r\n\r\n  function testCompare() public pure {\r\n    require(\"a\".compare(\"a\")  == 0 == true,  \"Compare equal\");\r\n    require(\"a\".compare(\"b\")   < 0 == true,   \"Compare different value with same length\");\r\n    require(\"b\".compare(\"a\")   > 0 == true,   \"Compare different value with same length\");\r\n    require(\"aa\".compare(\"ab\") < 0 == true,   \"Compare different value with multiple length\");\r\n    require(\"a\".compare(\"aa\")  < 0 == true,   \"Compare different value with different length\");\r\n    require(\"aa\".compare(\"a\")  > 0 == true,   \"Compare different value with different length\");\r\n    bytes memory longChar = \"1234567890123456789012345678901234\";\r\n    require(longChar.compare(longChar) == 0 == true,   \"Compares more than 32 bytes char\");\r\n    bytes memory otherLongChar = \"2234567890123456789012345678901234\";\r\n    require(longChar.compare(otherLongChar) < 0 == true,   \"Compare long char with difference at start\");\r\n  }\r\n\r\n  function testSubstring() public pure {\r\n    require(keccak256(bytes(\"hello\".substring(0, 0))) == keccak256(bytes(\"\")), \"Copy 0 bytes\");\r\n    require(keccak256(bytes(\"hello\".substring(0, 4))) == keccak256(bytes(\"hell\")), \"Copy substring\");\r\n    require(keccak256(bytes(\"hello\".substring(1, 4))) == keccak256(bytes(\"ello\")), \"Copy substring\");\r\n    require(keccak256(bytes(\"hello\".substring(0, 5))) == keccak256(bytes(\"hello\")), \"Copy whole string\");\r\n  }\r\n\r\n  function testReadUint8() public pure {\r\n    require(uint(\"a\".readUint8(0)) == 0x61, \"a == 0x61\");\r\n    require(uint(\"ba\".readUint8(1)) == 0x61, \"a == 0x61\");\r\n  }\r\n\r\n  function testReadUint16() public pure {\r\n    require(uint(\"abc\".readUint16(1)) == 0x6263, \"Read uint 16\");\r\n  }\r\n\r\n  function testReadUint32() public pure {\r\n    require(uint(\"abcde\".readUint32(1)) == 0x62636465, \"Read uint 32\");\r\n  }\r\n\r\n  function testReadBytes20() public pure {\r\n    require(bytes32(\"abcdefghijklmnopqrstuv\".readBytes20(1)) == bytes32(0x62636465666768696a6b6c6d6e6f707172737475000000000000000000000000), \"readBytes20\");\r\n  }\r\n\r\n  function testReadBytes32() public pure {\r\n    require(\"0123456789abcdef0123456789abcdef\".readBytes32(0) == bytes32(0x3031323334353637383961626364656630313233343536373839616263646566), \"readBytes32\");\r\n  }\r\n\r\n  function testBase32HexDecodeWord() public pure {\r\n    require(\"C4\".base32HexDecodeWord(0, 2) == bytes32(bytes1(\"a\")), \"Decode 'a'\");\r\n    require(\"C5GG\".base32HexDecodeWord(0, 4) == bytes32(bytes2(\"aa\")), \"Decode 'aa'\");\r\n    require(\"C5GM2\".base32HexDecodeWord(0, 5) == bytes32(bytes3(\"aaa\")), \"Decode 'aaa'\");\r\n    require(\"C5GM2O8\".base32HexDecodeWord(0, 7) == bytes32(bytes4(\"aaaa\")), \"Decode 'aaaa'\");\r\n    require(\"C5GM2OB1\".base32HexDecodeWord(0, 8) == bytes32(bytes5(\"aaaaa\")), \"Decode 'aaaaa'\");\r\n    require(\"c5gm2Ob1\".base32HexDecodeWord(0, 8) == bytes32(bytes5(\"aaaaa\")), \"Decode 'aaaaa' lowercase\");\r\n    require(\"C5H66P35CPJMGQBADDM6QRJFE1ON4SRKELR7EU3PF8\".base32HexDecodeWord(0, 42) == bytes32(bytes26(\"abcdefghijklmnopqrstuvwxyz\")), \"Decode alphabet\");\r\n    require(\"c5h66p35cpjmgqbaddm6qrjfe1on4srkelr7eu3pf8\".base32HexDecodeWord(0, 42) == bytes32(bytes26(\"abcdefghijklmnopqrstuvwxyz\")), \"Decode alphabet lowercase\");\r\n    require(\"C5GM2OB1C5GM2OB1C5GM2OB1C5GM2OB1C5GM2OB1C5GM2OB1C5GG\".base32HexDecodeWord(0, 52) == bytes32(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"), \"Decode 32*'a'\");\r\n    require(\" bst4hlje7r0o8c8p4o8q582lm0ejmiqt\\x07matoken\\x03xyz\\x00\".base32HexDecodeWord(1, 32) == bytes32(hex\"5f3a48d66e3ec18431192611a2a055b01d3b4b5d\"), \"Decode real bytes32hex\");\r\n  }\r\n}"
    },
    "contracts/dnssec-oracle/DNSSECImpl.sol": {
      "content": "pragma solidity ^0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./Owned.sol\";\r\nimport \"./BytesUtils.sol\";\r\nimport \"./RRUtils.sol\";\r\nimport \"./DNSSEC.sol\";\r\nimport \"./algorithms/Algorithm.sol\";\r\nimport \"./digests/Digest.sol\";\r\nimport \"./nsec3digests/NSEC3Digest.sol\";\r\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\r\n\r\n/*\r\n * @dev An oracle contract that verifies and stores DNSSEC-validated DNS records.\r\n *\r\n * TODO: Support for NSEC3 records\r\n */\r\ncontract DNSSECImpl is DNSSEC, Owned {\r\n    using Buffer for Buffer.buffer;\r\n    using BytesUtils for bytes;\r\n    using RRUtils for *;\r\n\r\n    uint16 constant DNSCLASS_IN = 1;\r\n\r\n    uint16 constant DNSTYPE_NS = 2;\r\n    uint16 constant DNSTYPE_SOA = 6;\r\n    uint16 constant DNSTYPE_DNAME = 39;\r\n    uint16 constant DNSTYPE_DS = 43;\r\n    uint16 constant DNSTYPE_RRSIG = 46;\r\n    uint16 constant DNSTYPE_NSEC = 47;\r\n    uint16 constant DNSTYPE_DNSKEY = 48;\r\n    uint16 constant DNSTYPE_NSEC3 = 50;\r\n\r\n    uint constant DNSKEY_FLAG_ZONEKEY = 0x100;\r\n\r\n    uint8 constant ALGORITHM_RSASHA256 = 8;\r\n\r\n    uint8 constant DIGEST_ALGORITHM_SHA256 = 2;\r\n\r\n    struct RRSet {\r\n        uint32 inception;\r\n        uint32 expiration;\r\n        bytes20 hash;\r\n    }\r\n\r\n    // (name, type) => RRSet\r\n    mapping (bytes32 => mapping(uint16 => RRSet)) rrsets;\r\n\r\n    mapping (uint8 => Algorithm) public algorithms;\r\n    mapping (uint8 => Digest) public digests;\r\n    mapping (uint8 => NSEC3Digest) public nsec3Digests;\r\n\r\n    event Test(uint t);\r\n    event Marker();\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param _anchors The binary format RR entries for the root DS records.\r\n     */\r\n    constructor(bytes memory _anchors) {\r\n        // Insert the 'trust anchors' - the key hashes that start the chain\r\n        // of trust for all other records.\r\n        anchors = _anchors;\r\n        rrsets[keccak256(hex\"00\")][DNSTYPE_DS] = RRSet({\r\n            inception: uint32(0),\r\n            expiration: uint32(3767581600), // May 22 2089 - the latest date we can encode as of writing this\r\n            hash: bytes20(keccak256(anchors))\r\n        });\r\n        emit RRSetUpdated(hex\"00\", anchors);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the contract address for a signature verification algorithm.\r\n     *      Callable only by the owner.\r\n     * @param id The algorithm ID\r\n     * @param algo The address of the algorithm contract.\r\n     */\r\n    function setAlgorithm(uint8 id, Algorithm algo) public owner_only {\r\n        algorithms[id] = algo;\r\n        emit AlgorithmUpdated(id, address(algo));\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the contract address for a digest verification algorithm.\r\n     *      Callable only by the owner.\r\n     * @param id The digest ID\r\n     * @param digest The address of the digest contract.\r\n     */\r\n    function setDigest(uint8 id, Digest digest) public owner_only {\r\n        digests[id] = digest;\r\n        emit DigestUpdated(id, address(digest));\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the contract address for an NSEC3 digest algorithm.\r\n     *      Callable only by the owner.\r\n     * @param id The digest ID\r\n     * @param digest The address of the digest contract.\r\n     */\r\n    function setNSEC3Digest(uint8 id, NSEC3Digest digest) public owner_only {\r\n        nsec3Digests[id] = digest;\r\n        emit NSEC3DigestUpdated(id, address(digest));\r\n    }\r\n\r\n    /**\r\n     * @dev Submits multiple RRSets\r\n     * @param input A list of RRSets and signatures forming a chain of trust from an existing known-good record.\r\n     * @param _proof The DNSKEY or DS to validate the first signature against.\r\n     * @return The last RRSET submitted.\r\n     */\r\n    function submitRRSets(RRSetWithSignature[] memory input, bytes calldata _proof) public override returns (bytes memory) {\r\n        bytes memory proof = _proof;\r\n        for(uint i = 0; i < input.length; i++) {\r\n            proof = _submitRRSet(input[i], proof);\r\n        }\r\n        return proof;\r\n    }\r\n\r\n    /**\r\n     * @dev Submits a signed set of RRs to the oracle.\r\n     *\r\n     * RRSETs are only accepted if they are signed with a key that is already\r\n     * trusted, or if they are self-signed, and the signing key is identified by\r\n     * a DS record that is already trusted.\r\n     *\r\n     * @param input The signed RR set. This is in the format described in section\r\n     *        5.3.2 of RFC4035: The RRDATA section from the RRSIG without the signature\r\n     *        data, followed by a series of canonicalised RR records that the signature\r\n     *        applies to.\r\n     * @param proof The DNSKEY or DS to validate the signature against. Must Already\r\n     *        have been submitted and proved previously.\r\n     */\r\n    function submitRRSet(RRSetWithSignature memory input, bytes memory proof)\r\n        public override\r\n        returns (bytes memory)\r\n    {\r\n        return _submitRRSet(input, proof);\r\n    }\r\n\r\n    /**\r\n     * @dev Deletes an RR from the oracle.\r\n     *\r\n     * @param deleteType The DNS record type to delete.\r\n     * @param deleteName which you want to delete\r\n     * @param nsec The signed NSEC RRset. This is in the format described in section\r\n     *        5.3.2 of RFC4035: The RRDATA section from the RRSIG without the signature\r\n     *        data, followed by a series of canonicalised RR records that the signature\r\n     *        applies to.\r\n     */\r\n    function deleteRRSet(uint16 deleteType, bytes memory deleteName, RRSetWithSignature memory nsec, bytes memory proof)\r\n        public override\r\n    {\r\n        RRUtils.SignedSet memory rrset;\r\n        rrset = validateSignedSet(nsec, proof);\r\n        require(rrset.typeCovered == DNSTYPE_NSEC);\r\n\r\n        // Don't let someone use an old proof to delete a new name\r\n        require(RRUtils.serialNumberGte(rrset.inception, rrsets[keccak256(deleteName)][deleteType].inception));\r\n\r\n        for (RRUtils.RRIterator memory iter = rrset.rrs(); !iter.done(); iter.next()) {\r\n            // We're dealing with three names here:\r\n            //   - deleteName is the name the user wants us to delete\r\n            //   - nsecName is the owner name of the NSEC record\r\n            //   - nextName is the next name specified in the NSEC record\r\n            //\r\n            // And three cases:\r\n            //   - deleteName equals nsecName, in which case we can delete the\r\n            //     record if it's not in the type bitmap.\r\n            //   - nextName comes after nsecName, in which case we can delete\r\n            //     the record if deleteName comes between nextName and nsecName.\r\n            //   - nextName comes before nsecName, in which case nextName is the\r\n            //     zone apex, and deleteName must come after nsecName.\r\n            checkNsecName(iter, rrset.name, deleteName, deleteType);\r\n            delete rrsets[keccak256(deleteName)][deleteType];\r\n            return;\r\n        }\r\n        // We should never reach this point\r\n        revert();\r\n    }\r\n\r\n    function checkNsecName(RRUtils.RRIterator memory iter, bytes memory nsecName, bytes memory deleteName, uint16 deleteType) private pure {\r\n        uint rdataOffset = iter.rdataOffset;\r\n        uint nextNameLength = iter.data.nameLength(rdataOffset);\r\n        uint rDataLength = iter.nextOffset - iter.rdataOffset;\r\n\r\n        // We assume that there is always typed bitmap after the next domain name\r\n        require(rDataLength > nextNameLength);\r\n\r\n        int compareResult = deleteName.compareNames(nsecName);\r\n        if(compareResult == 0) {\r\n            // Name to delete is on the same label as the NSEC record\r\n            require(!iter.data.checkTypeBitmap(rdataOffset + nextNameLength, deleteType));\r\n        } else {\r\n            // First check if the NSEC next name comes after the NSEC name.\r\n            bytes memory nextName = iter.data.substring(rdataOffset,nextNameLength);\r\n            // deleteName must come after nsecName\r\n            require(compareResult > 0);\r\n            if(nsecName.compareNames(nextName) < 0) {\r\n                // deleteName must also come before nextName\r\n                require(deleteName.compareNames(nextName) < 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Deletes an RR from the oracle using an NSEC3 proof.\r\n     *      Deleting a record using NSEC3 requires using up to two NSEC3 records. There are two cases:\r\n     *       1. The name exists, but the record type doesn't. Eg, example.com has A records but no TXT records.\r\n     *       2. The name does not exist, but a parent name does.\r\n     *      In the first case, we submit one NSEC3 proof in `closestEncloser` that matches the target name\r\n     *      but does not have the bit for `deleteType` set in its type bitmap. In the second case, we submit\r\n     *      two proofs: closestEncloser and nextClosest, that together prove that the name does not exist.\r\n     *      NSEC3 records are in the format described in section 5.3.2 of RFC4035: The RRDATA section\r\n     *      from the RRSIG without the signature data, followed by a series of canonicalised RR records\r\n     *      that the signature applies to.\r\n     *\r\n     * @param deleteType The DNS record type to delete.\r\n     * @param deleteName The name to delete.\r\n     * @param closestEncloser An NSEC3 proof matching the closest enclosing name - that is,\r\n     *        the nearest ancestor of the target name that *does* exist.\r\n     * @param nextClosest An NSEC3 proof covering the next closest name. This proves that the immediate\r\n     *        subdomain of the closestEncloser does not exist.\r\n     * @param dnskey An encoded DNSKEY record that has already been submitted to the oracle and can be used\r\n     *        to verify the signatures closestEncloserSig and nextClosestSig\r\n     */\r\n    function deleteRRSetNSEC3(uint16 deleteType, bytes memory deleteName, RRSetWithSignature memory closestEncloser, RRSetWithSignature memory nextClosest, bytes memory dnskey)\r\n        public override\r\n    {\r\n        uint32 originalInception = rrsets[keccak256(deleteName)][deleteType].inception;\r\n\r\n        RRUtils.SignedSet memory ce = validateSignedSet(closestEncloser, dnskey);\r\n        checkNSEC3Validity(ce, deleteName, originalInception);\r\n\r\n        RRUtils.SignedSet memory nc;\r\n        if(nextClosest.rrset.length > 0) {\r\n            nc = validateSignedSet(nextClosest, dnskey);\r\n            checkNSEC3Validity(nc, deleteName, originalInception);\r\n        }\r\n\r\n        RRUtils.NSEC3 memory ceNSEC3 = readNSEC3(ce);\r\n        // The flags field must be 0 or 1 (RFC5155 section 8.2).\r\n        require(ceNSEC3.flags & 0xfe == 0);\r\n        // Check that the closest encloser is from the correct zone (RFC5155 section 8.3)\r\n        // \"The DNAME type bit must not be set and the NS type bit may only be set if the SOA type bit is set.\"\r\n        require(!ceNSEC3.checkTypeBitmap(DNSTYPE_DNAME) && (!ceNSEC3.checkTypeBitmap(DNSTYPE_NS) || ceNSEC3.checkTypeBitmap(DNSTYPE_SOA)));\r\n\r\n        // Case 1: deleteName does exist, but no records of RRTYPE deleteType do.\r\n        if(isMatchingNSEC3Record(deleteType, deleteName, ce.name, ceNSEC3)) {\r\n            delete rrsets[keccak256(deleteName)][deleteType];\r\n        // Case 2: deleteName does not exist.\r\n        } else if(isCoveringNSEC3Record(deleteName, ce.name, ceNSEC3, nc.name, readNSEC3(nc))) {\r\n            delete rrsets[keccak256(deleteName)][deleteType];\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function checkNSEC3Validity(RRUtils.SignedSet memory nsec, bytes memory deleteName, uint32 originalInception) private pure {\r\n        // The records must have been signed after the record we're trying to delete\r\n        require(RRUtils.serialNumberGte(nsec.inception, originalInception));\r\n\r\n        // The record must be an NSEC3\r\n        require(nsec.typeCovered == DNSTYPE_NSEC3);\r\n\r\n        // nsecName is of the form <hash>.zone.xyz. <hash> is the NSEC3 hash of the entire name the NSEC3 record matches, while\r\n        // zone.xyz can be any ancestor of that name. We'll check that, so someone can't use a record on foo.com\r\n        // as proof of the nonexistence of bar.org.\r\n        require(checkNSEC3OwnerName(nsec.name, deleteName));\r\n    }\r\n\r\n    function isMatchingNSEC3Record(uint16 deleteType, bytes memory deleteName, bytes memory closestEncloserName, RRUtils.NSEC3 memory closestEncloser) private view returns(bool) {\r\n        // Check the record matches the hashed name, but the type bitmap does not include the type\r\n        if(checkNSEC3Name(closestEncloser, closestEncloserName, deleteName)) {\r\n            return !closestEncloser.checkTypeBitmap(deleteType);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function isCoveringNSEC3Record(bytes memory deleteName, bytes memory ceName, RRUtils.NSEC3 memory ce, bytes memory ncName, RRUtils.NSEC3 memory nc) private view returns(bool) {\r\n        // The flags field must be 0 or 1 (RFC5155 section 8.2).\r\n        require(nc.flags & 0xfe == 0);\r\n\r\n        bytes32 ceNameHash = decodeOwnerNameHash(ceName);\r\n        bytes32 ncNameHash = decodeOwnerNameHash(ncName);\r\n\r\n        uint lastOffset = 0;\r\n        // Iterate over suffixes of the name to delete until one matches the closest encloser\r\n        for(uint offset = deleteName.readUint8(0) + 1; offset < deleteName.length; offset += deleteName.readUint8(offset) + 1) {\r\n            if(hashName(ce, deleteName.substring(offset, deleteName.length - offset)) == ceNameHash) {\r\n                // Check that the next closest record encloses the name one label longer\r\n                bytes32 checkHash = hashName(nc, deleteName.substring(lastOffset, deleteName.length - lastOffset));\r\n                if(ncNameHash < nc.nextHashedOwnerName) {\r\n                    return checkHash > ncNameHash && checkHash < nc.nextHashedOwnerName;\r\n                } else {\r\n                    return checkHash > ncNameHash || checkHash < nc.nextHashedOwnerName;\r\n                }\r\n            }\r\n            lastOffset = offset;\r\n        }\r\n        // If we reached the root without finding a match, return false.\r\n        return false;\r\n    }\r\n\r\n    function readNSEC3(RRUtils.SignedSet memory ss) private pure returns(RRUtils.NSEC3 memory) {\r\n        RRUtils.RRIterator memory iter = ss.rrs();\r\n        return iter.data.readNSEC3(iter.rdataOffset, iter.nextOffset - iter.rdataOffset);\r\n    }\r\n\r\n    function checkNSEC3Name(RRUtils.NSEC3 memory nsec, bytes memory ownerName, bytes memory deleteName) private view returns(bool) {\r\n        // Compute the NSEC3 name hash of the name to delete.\r\n        bytes32 deleteNameHash = hashName(nsec, deleteName);\r\n\r\n        // Decode the NSEC3 name hash from the first label of the NSEC3 owner name.\r\n        bytes32 nsecNameHash = decodeOwnerNameHash(ownerName);\r\n\r\n        return deleteNameHash == nsecNameHash;\r\n    }\r\n\r\n    function hashName(RRUtils.NSEC3 memory nsec, bytes memory name) private view returns(bytes32) {\r\n        return nsec3Digests[nsec.hashAlgorithm].hash(nsec.salt, name, nsec.iterations);\r\n    }\r\n\r\n    function decodeOwnerNameHash(bytes memory name) private pure returns(bytes32) {\r\n        return name.base32HexDecodeWord(1, uint(name.readUint8(0)));\r\n    }\r\n\r\n    function checkNSEC3OwnerName(bytes memory nsecName, bytes memory deleteName) private pure returns(bool) {\r\n        uint nsecNameOffset = nsecName.readUint8(0) + 1;\r\n        uint deleteNameOffset = 0;\r\n        while(deleteNameOffset < deleteName.length) {\r\n            if(deleteName.equals(deleteNameOffset, nsecName, nsecNameOffset)) {\r\n                return true;\r\n            }\r\n            deleteNameOffset += deleteName.readUint8(deleteNameOffset) + 1;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns data about the RRs (if any) known to this oracle with the provided type and name.\r\n     * @param dnstype The DNS record type to query.\r\n     * @param name The name to query, in DNS label-sequence format.\r\n     * @return inception The unix timestamp (wrapped) at which the signature for this RRSET was created.\r\n     * @return expiration The unix timestamp (wrapped) at which the signature for this RRSET expires.\r\n     * @return hash The hash of the RRset.\r\n     */\r\n    function rrdata(uint16 dnstype, bytes calldata name) external override view returns (uint32, uint32, bytes20) {\r\n        RRSet storage result = rrsets[keccak256(name)][dnstype];\r\n        return (result.inception, result.expiration, result.hash);\r\n    }\r\n\r\n    function _submitRRSet(RRSetWithSignature memory input, bytes memory proof) internal returns (bytes memory) {\r\n        RRUtils.SignedSet memory rrset;\r\n        rrset = validateSignedSet(input, proof);\r\n\r\n        RRSet storage storedSet = rrsets[keccak256(rrset.name)][rrset.typeCovered];\r\n        if (storedSet.hash != bytes20(0)) {\r\n            // To replace an existing rrset, the signature must be at least as new\r\n            require(RRUtils.serialNumberGte(rrset.inception, storedSet.inception));\r\n        }\r\n        rrsets[keccak256(rrset.name)][rrset.typeCovered] = RRSet({\r\n            inception: rrset.inception,\r\n            expiration: rrset.expiration,\r\n            hash: bytes20(keccak256(rrset.data))\r\n        });\r\n\r\n        emit RRSetUpdated(rrset.name, rrset.data);\r\n\r\n        return rrset.data;\r\n    }\r\n\r\n    /**\r\n     * @dev Submits a signed set of RRs to the oracle.\r\n     *\r\n     * RRSETs are only accepted if they are signed with a key that is already\r\n     * trusted, or if they are self-signed, and the signing key is identified by\r\n     * a DS record that is already trusted.\r\n     *\r\n     * @param input The signed RR set. This is in the format described in section\r\n     *        5.3.2 of RFC4035: The RRDATA section from the RRSIG without the signature\r\n     *        data, followed by a series of canonicalised RR records that the signature\r\n     *        applies to.\r\n     * @param proof The DNSKEY or DS to validate the signature against. Must Already\r\n     *        have been submitted and proved previously.\r\n     */\r\n    function validateSignedSet(RRSetWithSignature memory input, bytes memory proof) internal view returns(RRUtils.SignedSet memory rrset) {\r\n        rrset = input.rrset.readSignedSet();\r\n        require(validProof(rrset.signerName, proof));\r\n\r\n        // Do some basic checks on the RRs and extract the name\r\n        bytes memory name = validateRRs(rrset, rrset.typeCovered);\r\n        require(name.labelCount(0) == rrset.labels);\r\n        rrset.name = name;\r\n\r\n        // All comparisons involving the Signature Expiration and\r\n        // Inception fields MUST use \"serial number arithmetic\", as\r\n        // defined in RFC 1982\r\n\r\n        // o  The validator's notion of the current time MUST be less than or\r\n        //    equal to the time listed in the RRSIG RR's Expiration field.\r\n        require(RRUtils.serialNumberGte(rrset.expiration, uint32(block.timestamp)));\r\n\r\n        // o  The validator's notion of the current time MUST be greater than or\r\n        //    equal to the time listed in the RRSIG RR's Inception field.\r\n        require(RRUtils.serialNumberGte(uint32(block.timestamp), rrset.inception));\r\n\r\n        // Validate the signature\r\n        verifySignature(name, rrset, input, proof);\r\n\r\n        return rrset;\r\n    }\r\n\r\n    function validProof(bytes memory name, bytes memory proof) internal view returns(bool) {\r\n        uint16 dnstype = proof.readUint16(proof.nameLength(0));\r\n        return rrsets[keccak256(name)][dnstype].hash == bytes20(keccak256(proof));\r\n    }\r\n\r\n    /**\r\n     * @dev Validates a set of RRs.\r\n     * @param rrset The RR set.\r\n     * @param typecovered The type covered by the RRSIG record.\r\n     */\r\n    function validateRRs(RRUtils.SignedSet memory rrset, uint16 typecovered) internal pure returns (bytes memory name) {\r\n        // Iterate over all the RRs\r\n        for (RRUtils.RRIterator memory iter = rrset.rrs(); !iter.done(); iter.next()) {\r\n            // We only support class IN (Internet)\r\n            require(iter.class == DNSCLASS_IN);\r\n\r\n            if(name.length == 0) {\r\n                name = iter.name();\r\n            } else {\r\n                // Name must be the same on all RRs. We do things this way to avoid copying the name\r\n                // repeatedly.\r\n                require(name.length == iter.data.nameLength(iter.offset));\r\n                require(name.equals(0, iter.data, iter.offset, name.length));\r\n            }\r\n\r\n            // o  The RRSIG RR's Type Covered field MUST equal the RRset's type.\r\n            require(iter.dnstype == typecovered);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs signature verification.\r\n     *\r\n     * Throws or reverts if unable to verify the record.\r\n     *\r\n     * @param name The name of the RRSIG record, in DNS label-sequence format.\r\n     * @param data The original data to verify.\r\n     * @param proof A DS or DNSKEY record that's already verified by the oracle.\r\n     */\r\n    function verifySignature(bytes memory name, RRUtils.SignedSet memory rrset, RRSetWithSignature memory data, bytes memory proof) internal view {\r\n        // o  The RRSIG RR's Signer's Name field MUST be the name of the zone\r\n        //    that contains the RRset.\r\n        require(rrset.signerName.length <= name.length);\r\n        require(rrset.signerName.equals(0, name, name.length - rrset.signerName.length));\r\n\r\n        RRUtils.RRIterator memory proofRR = proof.iterateRRs(0);\r\n        // Check the proof\r\n        if (proofRR.dnstype == DNSTYPE_DS) {\r\n            require(verifyWithDS(rrset, data, proofRR));\r\n        } else if (proofRR.dnstype == DNSTYPE_DNSKEY) {\r\n            require(verifyWithKnownKey(rrset, data, proofRR));\r\n        } else {\r\n            revert(\"No valid proof found\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to verify a signed RRSET against an already known public key.\r\n     * @param rrset The signed set to verify.\r\n     * @param data The original data the signed set was read from.\r\n     * @param proof The serialized DS or DNSKEY record to use as proof.\r\n     * @return True if the RRSET could be verified, false otherwise.\r\n     */\r\n    function verifyWithKnownKey(RRUtils.SignedSet memory rrset, RRSetWithSignature memory data, RRUtils.RRIterator memory proof) internal view returns(bool) {\r\n        // Check the DNSKEY's owner name matches the signer name on the RRSIG\r\n        require(proof.name().equals(rrset.signerName));\r\n        for(; !proof.done(); proof.next()) {\r\n            require(proof.name().equals(rrset.signerName));\r\n            bytes memory keyrdata = proof.rdata();\r\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(0, keyrdata.length);\r\n            if(verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to verify some data using a provided key and a signature.\r\n     * @param dnskey The dns key record to verify the signature with.\r\n     * @param rrset The signed RRSET being verified.\r\n     * @param data The original data `rrset` was decoded from.\r\n     * @return True iff the key verifies the signature.\r\n     */\r\n    function verifySignatureWithKey(RRUtils.DNSKEY memory dnskey, bytes memory keyrdata, RRUtils.SignedSet memory rrset, RRSetWithSignature memory data)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        // TODO: Check key isn't expired, unless updating key itself\r\n\r\n        // The Protocol Field MUST have value 3 (RFC4034 2.1.2)\r\n        if(dnskey.protocol != 3) {\r\n            return false;\r\n        }\r\n\r\n        // o The RRSIG RR's Signer's Name, Algorithm, and Key Tag fields MUST\r\n        //   match the owner name, algorithm, and key tag for some DNSKEY RR in\r\n        //   the zone's apex DNSKEY RRset.\r\n        if(dnskey.algorithm != rrset.algorithm) {\r\n            return false;\r\n        }\r\n        uint16 computedkeytag = keyrdata.computeKeytag();\r\n        if (computedkeytag != rrset.keytag) {\r\n            return false;\r\n        }\r\n\r\n        // o The matching DNSKEY RR MUST be present in the zone's apex DNSKEY\r\n        //   RRset, and MUST have the Zone Flag bit (DNSKEY RDATA Flag bit 7)\r\n        //   set.\r\n        if (dnskey.flags & DNSKEY_FLAG_ZONEKEY == 0) {\r\n            return false;\r\n        }\r\n\r\n        return algorithms[dnskey.algorithm].verify(keyrdata, data.rrset, data.sig);\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to verify a signed RRSET against an already known hash. This function assumes\r\n     *      that the record \r\n     * @param rrset The signed set to verify.\r\n     * @param data The original data the signed set was read from.\r\n     * @param proof The serialized DS or DNSKEY record to use as proof.\r\n     * @return True if the RRSET could be verified, false otherwise.\r\n     */\r\n    function verifyWithDS(RRUtils.SignedSet memory rrset, RRSetWithSignature memory data, RRUtils.RRIterator memory proof) internal view returns(bool) {\r\n        for(RRUtils.RRIterator memory iter = rrset.rrs(); !iter.done(); iter.next()) {\r\n            require(iter.dnstype == DNSTYPE_DNSKEY);\r\n            bytes memory keyrdata = iter.rdata();\r\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(0, keyrdata.length);\r\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\r\n                // It's self-signed - look for a DS record to verify it.\r\n                return verifyKeyWithDS(iter.name(), proof, dnskey, keyrdata);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to verify a key using DS records.\r\n     * @param keyname The DNS name of the key, in DNS label-sequence format.\r\n     * @param dsrrs The DS records to use in verification.\r\n     * @param dnskey The dnskey to verify.\r\n     * @param keyrdata The RDATA section of the key.\r\n     * @return True if a DS record verifies this key.\r\n     */\r\n    function verifyKeyWithDS(bytes memory keyname, RRUtils.RRIterator memory dsrrs, RRUtils.DNSKEY memory dnskey, bytes memory keyrdata)\r\n        internal view returns (bool)\r\n    {\r\n        uint16 keytag = keyrdata.computeKeytag();\r\n        for (; !dsrrs.done(); dsrrs.next()) {\r\n            RRUtils.DS memory ds = dsrrs.data.readDS(dsrrs.rdataOffset, dsrrs.nextOffset - dsrrs.rdataOffset);\r\n            if(ds.keytag != keytag) {\r\n                continue;\r\n            }\r\n            if (ds.algorithm != dnskey.algorithm) {\r\n                continue;\r\n            }\r\n\r\n            Buffer.buffer memory buf;\r\n            buf.init(keyname.length + keyrdata.length);\r\n            buf.append(keyname);\r\n            buf.append(keyrdata);\r\n            if (verifyDSHash(ds.digestType, buf.buf, ds.digest)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to verify a DS record's hash value against some data.\r\n     * @param digesttype The digest ID from the DS record.\r\n     * @param data The data to digest.\r\n     * @param digest The digest data to check against.\r\n     * @return True iff the digest matches.\r\n     */\r\n    function verifyDSHash(uint8 digesttype, bytes memory data, bytes memory digest) internal view returns (bool) {\r\n        if (address(digests[digesttype]) == address(0)) {\r\n            return false;\r\n        }\r\n        return digests[digesttype].verify(data, digest);\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/Owned.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\n/**\r\n* @dev Contract mixin for 'owned' contracts.\r\n*/\r\ncontract Owned {\r\n    address public owner;\r\n    \r\n    modifier owner_only() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function setOwner(address newOwner) public owner_only {\r\n        owner = newOwner;\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/algorithms/Algorithm.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\n/**\r\n* @dev An interface for contracts implementing a DNSSEC (signing) algorithm.\r\n*/\r\ninterface Algorithm {\r\n    /**\r\n    * @dev Verifies a signature.\r\n    * @param key The public key to verify with.\r\n    * @param data The signed data to verify.\r\n    * @param signature The signature to verify.\r\n    * @return True iff the signature is valid.\r\n    */\r\n    function verify(bytes calldata key, bytes calldata data, bytes calldata signature) external virtual view returns (bool);\r\n}\r\n"
    },
    "contracts/dnssec-oracle/digests/Digest.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\n/**\r\n* @dev An interface for contracts implementing a DNSSEC digest.\r\n*/\r\ninterface Digest {\r\n    /**\r\n    * @dev Verifies a cryptographic hash.\r\n    * @param data The data to hash.\r\n    * @param hash The hash to compare to.\r\n    * @return True iff the hashed data matches the provided hash value.\r\n    */\r\n    function verify(bytes calldata data, bytes calldata hash) external virtual pure returns (bool);\r\n}\r\n"
    },
    "contracts/dnssec-oracle/nsec3digests/NSEC3Digest.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev Interface for contracts that implement NSEC3 digest algorithms.\r\n */\r\ninterface NSEC3Digest {\r\n    /**\r\n     * @dev Performs an NSEC3 iterated hash.\r\n     * @param salt The salt value to use on each iteration.\r\n     * @param data The data to hash.\r\n     * @param iterations The number of iterations to perform.\r\n     * @return The result of the iterated hash operation.\r\n     */\r\n     function hash(bytes calldata salt, bytes calldata data, uint iterations) external virtual pure returns (bytes32);\r\n}\r\n"
    },
    "contracts/dnssec-oracle/nsec3digests/SHA1NSEC3Digest.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"./NSEC3Digest.sol\";\r\nimport \"../SHA1.sol\";\r\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\r\n/**\r\n* @dev Implements the DNSSEC iterated SHA1 digest used for NSEC3 records.\r\n*/\r\ncontract SHA1NSEC3Digest is NSEC3Digest {\r\n    using Buffer for Buffer.buffer;\r\n\r\n    function hash(bytes calldata salt, bytes calldata data, uint iterations) external override pure returns (bytes32) {\r\n        Buffer.buffer memory buf;\r\n        buf.init(salt.length + data.length + 16);\r\n\r\n        buf.append(data);\r\n        buf.append(salt);\r\n        bytes20 h = SHA1.sha1(buf.buf);\r\n        if (iterations > 0) {\r\n            buf.truncate();\r\n            buf.appendBytes20(bytes20(0));\r\n            buf.append(salt);\r\n\r\n            for (uint i = 0; i < iterations; i++) {\r\n                buf.writeBytes20(0, h);\r\n                h = SHA1.sha1(buf.buf);\r\n            }\r\n        }\r\n\r\n        return bytes32(h);\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/SHA1.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nlibrary SHA1 {\r\n    event Debug(bytes32 x);\r\n\r\n    function sha1(bytes memory data) internal pure returns(bytes20 ret) {\r\n        assembly {\r\n            // Get a safe scratch location\r\n            let scratch := mload(0x40)\r\n\r\n            // Get the data length, and point data at the first byte\r\n            let len := mload(data)\r\n            data := add(data, 32)\r\n\r\n            // Find the length after padding\r\n            let totallen := add(and(add(len, 1), 0xFFFFFFFFFFFFFFC0), 64)\r\n            switch lt(sub(totallen, len), 9)\r\n            case 1 { totallen := add(totallen, 64) }\r\n\r\n            let h := 0x6745230100EFCDAB890098BADCFE001032547600C3D2E1F0\r\n\r\n            function readword(ptr, off, count) -> result {\r\n                result := 0\r\n                if lt(off, count) {\r\n                    result := mload(add(ptr, off))\r\n                    count := sub(count, off)\r\n                    if lt(count, 32) {\r\n                        let mask := not(sub(exp(256, sub(32, count)), 1))\r\n                        result := and(result, mask)\r\n                    }\r\n                }\r\n            }\r\n\r\n            for { let i := 0 } lt(i, totallen) { i := add(i, 64) } {\r\n                mstore(scratch, readword(data, i, len))\r\n                mstore(add(scratch, 32), readword(data, add(i, 32), len))\r\n\r\n                // If we loaded the last byte, store the terminator byte\r\n                switch lt(sub(len, i), 64)\r\n                case 1 { mstore8(add(scratch, sub(len, i)), 0x80) }\r\n\r\n                // If this is the last block, store the length\r\n                switch eq(i, sub(totallen, 64))\r\n                case 1 { mstore(add(scratch, 32), or(mload(add(scratch, 32)), mul(len, 8))) }\r\n\r\n                // Expand the 16 32-bit words into 80\r\n                for { let j := 64 } lt(j, 128) { j := add(j, 12) } {\r\n                    let temp := xor(xor(mload(add(scratch, sub(j, 12))), mload(add(scratch, sub(j, 32)))), xor(mload(add(scratch, sub(j, 56))), mload(add(scratch, sub(j, 64)))))\r\n                    temp := or(and(mul(temp, 2), 0xFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFE), and(div(temp, 0x80000000), 0x0000000100000001000000010000000100000001000000010000000100000001))\r\n                    mstore(add(scratch, j), temp)\r\n                }\r\n                for { let j := 128 } lt(j, 320) { j := add(j, 24) } {\r\n                    let temp := xor(xor(mload(add(scratch, sub(j, 24))), mload(add(scratch, sub(j, 64)))), xor(mload(add(scratch, sub(j, 112))), mload(add(scratch, sub(j, 128)))))\r\n                    temp := or(and(mul(temp, 4), 0xFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFC), and(div(temp, 0x40000000), 0x0000000300000003000000030000000300000003000000030000000300000003))\r\n                    mstore(add(scratch, j), temp)\r\n                }\r\n\r\n                let x := h\r\n                let f := 0\r\n                let k := 0\r\n                for { let j := 0 } lt(j, 80) { j := add(j, 1) } {\r\n                    switch div(j, 20)\r\n                    case 0 {\r\n                        // f = d xor (b and (c xor d))\r\n                        f := xor(div(x, 0x100000000000000000000), div(x, 0x10000000000))\r\n                        f := and(div(x, 0x1000000000000000000000000000000), f)\r\n                        f := xor(div(x, 0x10000000000), f)\r\n                        k := 0x5A827999\r\n                    }\r\n                    case 1{\r\n                        // f = b xor c xor d\r\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\r\n                        f := xor(div(x, 0x10000000000), f)\r\n                        k := 0x6ED9EBA1\r\n                    }\r\n                    case 2 {\r\n                        // f = (b and c) or (d and (b or c))\r\n                        f := or(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\r\n                        f := and(div(x, 0x10000000000), f)\r\n                        f := or(and(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000)), f)\r\n                        k := 0x8F1BBCDC\r\n                    }\r\n                    case 3 {\r\n                        // f = b xor c xor d\r\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\r\n                        f := xor(div(x, 0x10000000000), f)\r\n                        k := 0xCA62C1D6\r\n                    }\r\n                    // temp = (a leftrotate 5) + f + e + k + w[i]\r\n                    let temp := and(div(x, 0x80000000000000000000000000000000000000000000000), 0x1F)\r\n                    temp := or(and(div(x, 0x800000000000000000000000000000000000000), 0xFFFFFFE0), temp)\r\n                    temp := add(f, temp)\r\n                    temp := add(and(x, 0xFFFFFFFF), temp)\r\n                    temp := add(k, temp)\r\n                    temp := add(div(mload(add(scratch, mul(j, 4))), 0x100000000000000000000000000000000000000000000000000000000), temp)\r\n                    x := or(div(x, 0x10000000000), mul(temp, 0x10000000000000000000000000000000000000000))\r\n                    x := or(and(x, 0xFFFFFFFF00FFFFFFFF000000000000FFFFFFFF00FFFFFFFF), mul(or(and(div(x, 0x4000000000000), 0xC0000000), and(div(x, 0x400000000000000000000), 0x3FFFFFFF)), 0x100000000000000000000))\r\n                }\r\n\r\n                h := and(add(h, x), 0xFFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF)\r\n            }\r\n            ret := mul(or(or(or(or(and(div(h, 0x100000000), 0xFFFFFFFF00000000000000000000000000000000), and(div(h, 0x1000000), 0xFFFFFFFF000000000000000000000000)), and(div(h, 0x10000), 0xFFFFFFFF0000000000000000)), and(div(h, 0x100), 0xFFFFFFFF00000000)), and(h, 0xFFFFFFFF)), 0x1000000000000000000000000)\r\n        }\r\n    }\r\n}"
    },
    "contracts/ethregistrar/mocks/DummyDNSSEC.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nimport \"../../registry/ENSRegistry.sol\";\r\nimport \"../../dnssec-oracle/DNSSEC.sol\";\r\n\r\ncontract DummyDnsRegistrarDNSSEC {\r\n\r\n    struct Data {\r\n        uint32 inception;\r\n        uint64 inserted;\r\n        bytes20 hash;\r\n    }\r\n\r\n    mapping (bytes32 => Data) private datas;\r\n\r\n    function setData(uint16 _expectedType, bytes memory _expectedName, uint32 _inception, uint64 _inserted, bytes memory _proof) public {\r\n        Data storage rr = datas[keccak256(abi.encodePacked(_expectedType, _expectedName))];\r\n        rr.inception = _inception;\r\n        rr.inserted = _inserted;\r\n\r\n        if (_proof.length != 0) {\r\n            rr.hash = bytes20(keccak256(_proof));\r\n        } else {\r\n            rr.hash = bytes20(0);\r\n        }\r\n    }\r\n\r\n    function rrdata(uint16 dnstype, bytes memory name) public view returns (uint32, uint64, bytes20) {\r\n        Data storage rr = datas[keccak256(abi.encodePacked(dnstype, name))];\r\n        return (rr.inception, rr.inserted, rr.hash);\r\n    }\r\n\r\n    function submitRRSets(DNSSEC.RRSetWithSignature[] memory input, bytes calldata) public virtual returns (bytes memory) {\r\n        return input[input.length - 1].rrset;\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/digests/SHA256Digest.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"./Digest.sol\";\r\nimport \"../BytesUtils.sol\";\r\n\r\n/**\r\n* @dev Implements the DNSSEC SHA256 digest.\r\n*/\r\ncontract SHA256Digest is Digest {\r\n    using BytesUtils for *;\r\n\r\n    function verify(bytes calldata data, bytes calldata hash) external override pure returns (bool) {\r\n        require(hash.length == 32, \"Invalid sha256 hash length\");\r\n        return sha256(data) == hash.readBytes32(0);\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/digests/SHA1Digest.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"./Digest.sol\";\r\nimport \"../BytesUtils.sol\";\r\nimport \"@ensdomains/solsha1/contracts/SHA1.sol\";\r\n\r\n/**\r\n* @dev Implements the DNSSEC SHA1 digest.\r\n*/\r\ncontract SHA1Digest is Digest {\r\n    using BytesUtils for *;\r\n\r\n    function verify(bytes calldata data, bytes calldata hash) external override pure returns (bool) {\r\n        require(hash.length == 20, \"Invalid sha1 hash length\");\r\n        bytes32 expected = hash.readBytes20(0);\r\n        bytes20 computed = SHA1.sha1(data);\r\n        return expected == computed;\r\n    }\r\n}\r\n"
    },
    "@ensdomains/solsha1/contracts/SHA1.sol": {
      "content": "pragma solidity ^0.8.4;\n\nlibrary SHA1 {\n    event Debug(bytes32 x);\n\n    function sha1(bytes memory data) internal pure returns(bytes20 ret) {\n        assembly {\n            // Get a safe scratch location\n            let scratch := mload(0x40)\n\n            // Get the data length, and point data at the first byte\n            let len := mload(data)\n            data := add(data, 32)\n\n            // Find the length after padding\n            let totallen := add(and(add(len, 1), 0xFFFFFFFFFFFFFFC0), 64)\n            switch lt(sub(totallen, len), 9)\n            case 1 { totallen := add(totallen, 64) }\n\n            let h := 0x6745230100EFCDAB890098BADCFE001032547600C3D2E1F0\n\n            function readword(ptr, off, count) -> result {\n                result := 0\n                if lt(off, count) {\n                    result := mload(add(ptr, off))\n                    count := sub(count, off)\n                    if lt(count, 32) {\n                        let mask := not(sub(exp(256, sub(32, count)), 1))\n                        result := and(result, mask)\n                    }\n                }\n            }\n\n            for { let i := 0 } lt(i, totallen) { i := add(i, 64) } {\n                mstore(scratch, readword(data, i, len))\n                mstore(add(scratch, 32), readword(data, add(i, 32), len))\n\n                // If we loaded the last byte, store the terminator byte\n                switch lt(sub(len, i), 64)\n                case 1 { mstore8(add(scratch, sub(len, i)), 0x80) }\n\n                // If this is the last block, store the length\n                switch eq(i, sub(totallen, 64))\n                case 1 { mstore(add(scratch, 32), or(mload(add(scratch, 32)), mul(len, 8))) }\n\n                // Expand the 16 32-bit words into 80\n                for { let j := 64 } lt(j, 128) { j := add(j, 12) } {\n                    let temp := xor(xor(mload(add(scratch, sub(j, 12))), mload(add(scratch, sub(j, 32)))), xor(mload(add(scratch, sub(j, 56))), mload(add(scratch, sub(j, 64)))))\n                    temp := or(and(mul(temp, 2), 0xFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFE), and(div(temp, 0x80000000), 0x0000000100000001000000010000000100000001000000010000000100000001))\n                    mstore(add(scratch, j), temp)\n                }\n                for { let j := 128 } lt(j, 320) { j := add(j, 24) } {\n                    let temp := xor(xor(mload(add(scratch, sub(j, 24))), mload(add(scratch, sub(j, 64)))), xor(mload(add(scratch, sub(j, 112))), mload(add(scratch, sub(j, 128)))))\n                    temp := or(and(mul(temp, 4), 0xFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFC), and(div(temp, 0x40000000), 0x0000000300000003000000030000000300000003000000030000000300000003))\n                    mstore(add(scratch, j), temp)\n                }\n\n                let x := h\n                let f := 0\n                let k := 0\n                for { let j := 0 } lt(j, 80) { j := add(j, 1) } {\n                    switch div(j, 20)\n                    case 0 {\n                        // f = d xor (b and (c xor d))\n                        f := xor(div(x, 0x100000000000000000000), div(x, 0x10000000000))\n                        f := and(div(x, 0x1000000000000000000000000000000), f)\n                        f := xor(div(x, 0x10000000000), f)\n                        k := 0x5A827999\n                    }\n                    case 1{\n                        // f = b xor c xor d\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\n                        f := xor(div(x, 0x10000000000), f)\n                        k := 0x6ED9EBA1\n                    }\n                    case 2 {\n                        // f = (b and c) or (d and (b or c))\n                        f := or(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\n                        f := and(div(x, 0x10000000000), f)\n                        f := or(and(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000)), f)\n                        k := 0x8F1BBCDC\n                    }\n                    case 3 {\n                        // f = b xor c xor d\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\n                        f := xor(div(x, 0x10000000000), f)\n                        k := 0xCA62C1D6\n                    }\n                    // temp = (a leftrotate 5) + f + e + k + w[i]\n                    let temp := and(div(x, 0x80000000000000000000000000000000000000000000000), 0x1F)\n                    temp := or(and(div(x, 0x800000000000000000000000000000000000000), 0xFFFFFFE0), temp)\n                    temp := add(f, temp)\n                    temp := add(and(x, 0xFFFFFFFF), temp)\n                    temp := add(k, temp)\n                    temp := add(div(mload(add(scratch, mul(j, 4))), 0x100000000000000000000000000000000000000000000000000000000), temp)\n                    x := or(div(x, 0x10000000000), mul(temp, 0x10000000000000000000000000000000000000000))\n                    x := or(and(x, 0xFFFFFFFF00FFFFFFFF000000000000FFFFFFFF00FFFFFFFF), mul(or(and(div(x, 0x4000000000000), 0xC0000000), and(div(x, 0x400000000000000000000), 0x3FFFFFFF)), 0x100000000000000000000))\n                }\n\n                h := and(add(h, x), 0xFFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF)\n            }\n            ret := mul(or(or(or(or(and(div(h, 0x100000000), 0xFFFFFFFF00000000000000000000000000000000), and(div(h, 0x1000000), 0xFFFFFFFF000000000000000000000000)), and(div(h, 0x10000), 0xFFFFFFFF0000000000000000)), and(div(h, 0x100), 0xFFFFFFFF00000000)), and(h, 0xFFFFFFFF)), 0x1000000000000000000000000)\n        }\n    }\n}\n"
    },
    "contracts/dnssec-oracle/algorithms/RSASHA1Algorithm.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"./Algorithm.sol\";\r\nimport \"../BytesUtils.sol\";\r\nimport \"./RSAVerify.sol\";\r\nimport \"@ensdomains/solsha1/contracts/SHA1.sol\";\r\n\r\n/**\r\n* @dev Implements the DNSSEC RSASHA1 algorithm.\r\n*/\r\ncontract RSASHA1Algorithm is Algorithm {\r\n    using BytesUtils for *;\r\n\r\n    function verify(bytes calldata key, bytes calldata data, bytes calldata sig) external override view returns (bool) {\r\n        bytes memory exponent;\r\n        bytes memory modulus;\r\n\r\n        uint16 exponentLen = uint16(key.readUint8(4));\r\n        if (exponentLen != 0) {\r\n            exponent = key.substring(5, exponentLen);\r\n            modulus = key.substring(exponentLen + 5, key.length - exponentLen - 5);\r\n        } else {\r\n            exponentLen = key.readUint16(5);\r\n            exponent = key.substring(7, exponentLen);\r\n            modulus = key.substring(exponentLen + 7, key.length - exponentLen - 7);\r\n        }\r\n\r\n        // Recover the message from the signature\r\n        bool ok;\r\n        bytes memory result;\r\n        (ok, result) = RSAVerify.rsarecover(modulus, exponent, sig);\r\n\r\n        // Verify it ends with the hash of our data\r\n        return ok && SHA1.sha1(data) == result.readBytes20(result.length - 20);\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/algorithms/RSAVerify.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"../BytesUtils.sol\";\r\nimport \"./ModexpPrecompile.sol\";\r\n\r\nlibrary RSAVerify {\r\n    /**\r\n    * @dev Recovers the input data from an RSA signature, returning the result in S.\r\n    * @param N The RSA public modulus.\r\n    * @param E The RSA public exponent.\r\n    * @param S The signature to recover.\r\n    * @return True if the recovery succeeded.\r\n    */\r\n    function rsarecover(bytes memory N, bytes memory E, bytes memory S) internal view returns (bool, bytes memory) {\r\n        return ModexpPrecompile.modexp(S, E, N);\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/algorithms/ModexpPrecompile.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nlibrary ModexpPrecompile {\r\n    /**\r\n    * @dev Computes (base ^ exponent) % modulus over big numbers.\r\n    */\r\n    function modexp(bytes memory base, bytes memory exponent, bytes memory modulus) internal view returns (bool success, bytes memory output) {\r\n        bytes memory input = abi.encodePacked(\r\n            uint256(base.length),\r\n            uint256(exponent.length),\r\n            uint256(modulus.length),\r\n            base,\r\n            exponent,\r\n            modulus\r\n        );\r\n\r\n        output = new bytes(modulus.length);\r\n\r\n        assembly {\r\n            success := staticcall(gas(), 5, add(input, 32), mload(input), add(output, 32), mload(modulus))\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/algorithms/RSASHA256Algorithm.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"./Algorithm.sol\";\r\nimport \"../BytesUtils.sol\";\r\nimport \"./RSAVerify.sol\";\r\n\r\n/**\r\n* @dev Implements the DNSSEC RSASHA256 algorithm.\r\n*/\r\ncontract RSASHA256Algorithm is Algorithm {\r\n    using BytesUtils for *;\r\n\r\n    function verify(bytes calldata key, bytes calldata data, bytes calldata sig) external override view returns (bool) {\r\n        bytes memory exponent;\r\n        bytes memory modulus;\r\n\r\n        uint16 exponentLen = uint16(key.readUint8(4));\r\n        if (exponentLen != 0) {\r\n            exponent = key.substring(5, exponentLen);\r\n            modulus = key.substring(exponentLen + 5, key.length - exponentLen - 5);\r\n        } else {\r\n            exponentLen = key.readUint16(5);\r\n            exponent = key.substring(7, exponentLen);\r\n            modulus = key.substring(exponentLen + 7, key.length - exponentLen - 7);\r\n        }\r\n\r\n        // Recover the message from the signature\r\n        bool ok;\r\n        bytes memory result;\r\n        (ok, result) = RSAVerify.rsarecover(modulus, exponent, sig);\r\n\r\n        // Verify it ends with the hash of our data\r\n        return ok && sha256(data) == result.readBytes32(result.length - 32);\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"./Algorithm.sol\";\r\nimport \"./EllipticCurve.sol\";\r\nimport \"../BytesUtils.sol\";\r\n\r\ncontract P256SHA256Algorithm is Algorithm, EllipticCurve {\r\n\r\n    using BytesUtils for *;\r\n\r\n    /**\r\n    * @dev Verifies a signature.\r\n    * @param key The public key to verify with.\r\n    * @param data The signed data to verify.\r\n    * @param signature The signature to verify.\r\n    * @return True iff the signature is valid.\r\n    */\r\n    function verify(bytes calldata key, bytes calldata data, bytes calldata signature) external override view returns (bool) {\r\n        return validateSignature(sha256(data), parseSignature(signature), parseKey(key));\r\n    }\r\n\r\n    function parseSignature(bytes memory data) internal pure returns (uint256[2] memory) {\r\n        require(data.length == 64, \"Invalid p256 signature length\");\r\n        return [uint256(data.readBytes32(0)), uint256(data.readBytes32(32))];\r\n    }\r\n\r\n    function parseKey(bytes memory data) internal pure returns (uint256[2] memory) {\r\n        require(data.length == 68, \"Invalid p256 key length\");\r\n        return [uint256(data.readBytes32(4)), uint256(data.readBytes32(36))];\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/algorithms/EllipticCurve.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\n/**\r\n * @title   EllipticCurve\r\n *\r\n * @author  Tilman Drerup;\r\n *\r\n * @notice  Implements elliptic curve math; Parametrized for SECP256R1.\r\n *\r\n *          Includes components of code by Andreas Olofsson, Alexander Vlasov\r\n *          (https://github.com/BANKEX/CurveArithmetics), and Avi Asayag\r\n *          (https://github.com/orbs-network/elliptic-curve-solidity)\r\n *\r\n *          Source: https://github.com/tdrerup/elliptic-curve-solidity\r\n *\r\n * @dev     NOTE: To disambiguate public keys when verifying signatures, activate\r\n *          condition 'rs[1] > lowSmax' in validateSignature().\r\n */\r\ncontract EllipticCurve {\r\n\r\n    // Set parameters for curve.\r\n    uint constant a = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\r\n    uint constant b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\r\n    uint constant gx = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\r\n    uint constant gy = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\r\n    uint constant p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\r\n    uint constant n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\r\n\r\n    uint constant lowSmax = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\r\n\r\n    /**\r\n     * @dev Inverse of u in the field of modulo m.\r\n     */\r\n    function inverseMod(uint u, uint m) internal pure\r\n        returns (uint)\r\n    {\r\n        unchecked {\r\n            if (u == 0 || u == m || m == 0)\r\n                return 0;\r\n            if (u > m)\r\n                u = u % m;\r\n\r\n            int t1;\r\n            int t2 = 1;\r\n            uint r1 = m;\r\n            uint r2 = u;\r\n            uint q;\r\n\r\n            while (r2 != 0) {\r\n                q = r1 / r2;\r\n                (t1, t2, r1, r2) = (t2, t1 - int(q) * t2, r2, r1 - q * r2);\r\n            }\r\n\r\n            if (t1 < 0)\r\n                return (m - uint(-t1));\r\n\r\n            return uint(t1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transform affine coordinates into projective coordinates.\r\n     */\r\n    function toProjectivePoint(uint x0, uint y0) internal pure\r\n        returns (uint[3] memory P)\r\n    {\r\n        P[2] = addmod(0, 1, p);\r\n        P[0] = mulmod(x0, P[2], p);\r\n        P[1] = mulmod(y0, P[2], p);\r\n    }\r\n\r\n    /**\r\n     * @dev Add two points in affine coordinates and return projective point.\r\n     */\r\n    function addAndReturnProjectivePoint(uint x1, uint y1, uint x2, uint y2) internal pure\r\n        returns (uint[3] memory P)\r\n    {\r\n        uint x;\r\n        uint y;\r\n        (x, y) = add(x1, y1, x2, y2);\r\n        P = toProjectivePoint(x, y);\r\n    }\r\n\r\n    /**\r\n     * @dev Transform from projective to affine coordinates.\r\n     */\r\n    function toAffinePoint(uint x0, uint y0, uint z0) internal pure\r\n        returns (uint x1, uint y1)\r\n    {\r\n        uint z0Inv;\r\n        z0Inv = inverseMod(z0, p);\r\n        x1 = mulmod(x0, z0Inv, p);\r\n        y1 = mulmod(y0, z0Inv, p);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the zero curve in projective coordinates.\r\n     */\r\n    function zeroProj() internal pure\r\n        returns (uint x, uint y, uint z)\r\n    {\r\n        return (0, 1, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the zero curve in affine coordinates.\r\n     */\r\n    function zeroAffine() internal pure\r\n        returns (uint x, uint y)\r\n    {\r\n        return (0, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if the curve is the zero curve.\r\n     */\r\n    function isZeroCurve(uint x0, uint y0) internal pure\r\n        returns (bool isZero)\r\n    {\r\n        if(x0 == 0 && y0 == 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if a point in affine coordinates is on the curve.\r\n     */\r\n    function isOnCurve(uint x, uint y) internal pure\r\n        returns (bool)\r\n    {\r\n        if (0 == x || x == p || 0 == y || y == p) {\r\n            return false;\r\n        }\r\n\r\n        uint LHS = mulmod(y, y, p); // y^2\r\n        uint RHS = mulmod(mulmod(x, x, p), x, p); // x^3\r\n\r\n        if (a != 0) {\r\n            RHS = addmod(RHS, mulmod(x, a, p), p); // x^3 + a*x\r\n        }\r\n        if (b != 0) {\r\n            RHS = addmod(RHS, b, p); // x^3 + a*x + b\r\n        }\r\n\r\n        return LHS == RHS;\r\n    }\r\n\r\n    /**\r\n     * @dev Double an elliptic curve point in projective coordinates. See\r\n     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\r\n     */\r\n    function twiceProj(uint x0, uint y0, uint z0) internal pure\r\n        returns (uint x1, uint y1, uint z1)\r\n    {\r\n        uint t;\r\n        uint u;\r\n        uint v;\r\n        uint w;\r\n\r\n        if(isZeroCurve(x0, y0)) {\r\n            return zeroProj();\r\n        }\r\n\r\n        u = mulmod(y0, z0, p);\r\n        u = mulmod(u, 2, p);\r\n\r\n        v = mulmod(u, x0, p);\r\n        v = mulmod(v, y0, p);\r\n        v = mulmod(v, 2, p);\r\n\r\n        x0 = mulmod(x0, x0, p);\r\n        t = mulmod(x0, 3, p);\r\n\r\n        z0 = mulmod(z0, z0, p);\r\n        z0 = mulmod(z0, a, p);\r\n        t = addmod(t, z0, p);\r\n\r\n        w = mulmod(t, t, p);\r\n        x0 = mulmod(2, v, p);\r\n        w = addmod(w, p-x0, p);\r\n\r\n        x0 = addmod(v, p-w, p);\r\n        x0 = mulmod(t, x0, p);\r\n        y0 = mulmod(y0, u, p);\r\n        y0 = mulmod(y0, y0, p);\r\n        y0 = mulmod(2, y0, p);\r\n        y1 = addmod(x0, p-y0, p);\r\n\r\n        x1 = mulmod(u, w, p);\r\n\r\n        z1 = mulmod(u, u, p);\r\n        z1 = mulmod(z1, u, p);\r\n    }\r\n\r\n    /**\r\n     * @dev Add two elliptic curve points in projective coordinates. See\r\n     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\r\n     */\r\n    function addProj(uint x0, uint y0, uint z0, uint x1, uint y1, uint z1) internal pure\r\n        returns (uint x2, uint y2, uint z2)\r\n    {\r\n        uint t0;\r\n        uint t1;\r\n        uint u0;\r\n        uint u1;\r\n\r\n        if (isZeroCurve(x0, y0)) {\r\n            return (x1, y1, z1);\r\n        }\r\n        else if (isZeroCurve(x1, y1)) {\r\n            return (x0, y0, z0);\r\n        }\r\n\r\n        t0 = mulmod(y0, z1, p);\r\n        t1 = mulmod(y1, z0, p);\r\n\r\n        u0 = mulmod(x0, z1, p);\r\n        u1 = mulmod(x1, z0, p);\r\n\r\n        if (u0 == u1) {\r\n            if (t0 == t1) {\r\n                return twiceProj(x0, y0, z0);\r\n            }\r\n            else {\r\n                return zeroProj();\r\n            }\r\n        }\r\n\r\n        (x2, y2, z2) = addProj2(mulmod(z0, z1, p), u0, u1, t1, t0);\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function that splits addProj to avoid too many local variables.\r\n     */\r\n    function addProj2(uint v, uint u0, uint u1, uint t1, uint t0) private pure\r\n        returns (uint x2, uint y2, uint z2)\r\n    {\r\n        uint u;\r\n        uint u2;\r\n        uint u3;\r\n        uint w;\r\n        uint t;\r\n\r\n        t = addmod(t0, p-t1, p);\r\n        u = addmod(u0, p-u1, p);\r\n        u2 = mulmod(u, u, p);\r\n\r\n        w = mulmod(t, t, p);\r\n        w = mulmod(w, v, p);\r\n        u1 = addmod(u1, u0, p);\r\n        u1 = mulmod(u1, u2, p);\r\n        w = addmod(w, p-u1, p);\r\n\r\n        x2 = mulmod(u, w, p);\r\n\r\n        u3 = mulmod(u2, u, p);\r\n        u0 = mulmod(u0, u2, p);\r\n        u0 = addmod(u0, p-w, p);\r\n        t = mulmod(t, u0, p);\r\n        t0 = mulmod(t0, u3, p);\r\n\r\n        y2 = addmod(t, p-t0, p);\r\n\r\n        z2 = mulmod(u3, v, p);\r\n    }\r\n\r\n    /**\r\n     * @dev Add two elliptic curve points in affine coordinates.\r\n     */\r\n    function add(uint x0, uint y0, uint x1, uint y1) internal pure\r\n        returns (uint, uint)\r\n    {\r\n        uint z0;\r\n\r\n        (x0, y0, z0) = addProj(x0, y0, 1, x1, y1, 1);\r\n\r\n        return toAffinePoint(x0, y0, z0);\r\n    }\r\n\r\n    /**\r\n     * @dev Double an elliptic curve point in affine coordinates.\r\n     */\r\n    function twice(uint x0, uint y0) internal pure\r\n        returns (uint, uint)\r\n    {\r\n        uint z0;\r\n\r\n        (x0, y0, z0) = twiceProj(x0, y0, 1);\r\n\r\n        return toAffinePoint(x0, y0, z0);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an elliptic curve point by a 2 power base (i.e., (2^exp)*P)).\r\n     */\r\n    function multiplyPowerBase2(uint x0, uint y0, uint exp) internal pure\r\n        returns (uint, uint)\r\n    {\r\n        uint base2X = x0;\r\n        uint base2Y = y0;\r\n        uint base2Z = 1;\r\n\r\n        for(uint i = 0; i < exp; i++) {\r\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\r\n        }\r\n\r\n        return toAffinePoint(base2X, base2Y, base2Z);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an elliptic curve point by a scalar.\r\n     */\r\n    function multiplyScalar(uint x0, uint y0, uint scalar) internal pure\r\n        returns (uint x1, uint y1)\r\n    {\r\n        if(scalar == 0) {\r\n            return zeroAffine();\r\n        }\r\n        else if (scalar == 1) {\r\n            return (x0, y0);\r\n        }\r\n        else if (scalar == 2) {\r\n            return twice(x0, y0);\r\n        }\r\n\r\n        uint base2X = x0;\r\n        uint base2Y = y0;\r\n        uint base2Z = 1;\r\n        uint z1 = 1;\r\n        x1 = x0;\r\n        y1 = y0;\r\n\r\n        if(scalar%2 == 0) {\r\n            x1 = y1 = 0;\r\n        }\r\n\r\n        scalar = scalar >> 1;\r\n\r\n        while(scalar > 0) {\r\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\r\n\r\n            if(scalar%2 == 1) {\r\n                (x1, y1, z1) = addProj(base2X, base2Y, base2Z, x1, y1, z1);\r\n            }\r\n\r\n            scalar = scalar >> 1;\r\n        }\r\n\r\n        return toAffinePoint(x1, y1, z1);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply the curve's generator point by a scalar.\r\n     */\r\n    function multipleGeneratorByScalar(uint scalar) internal pure\r\n        returns (uint, uint)\r\n    {\r\n        return multiplyScalar(gx, gy, scalar);\r\n    }\r\n\r\n    /**\r\n     * @dev Validate combination of message, signature, and public key.\r\n     */\r\n    function validateSignature(bytes32 message, uint[2] memory rs, uint[2] memory Q) internal pure\r\n        returns (bool)\r\n    {\r\n\r\n        // To disambiguate between public key solutions, include comment below.\r\n        if(rs[0] == 0 || rs[0] >= n || rs[1] == 0) {// || rs[1] > lowSmax)\r\n            return false;\r\n        }\r\n        if (!isOnCurve(Q[0], Q[1])) {\r\n            return false;\r\n        }\r\n\r\n        uint x1;\r\n        uint x2;\r\n        uint y1;\r\n        uint y2;\r\n\r\n        uint sInv = inverseMod(rs[1], n);\r\n        (x1, y1) = multiplyScalar(gx, gy, mulmod(uint(message), sInv, n));\r\n        (x2, y2) = multiplyScalar(Q[0], Q[1], mulmod(rs[0], sInv, n));\r\n        uint[3] memory P = addAndReturnProjectivePoint(x1, y1, x2, y2);\r\n\r\n        if (P[2] == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint Px = inverseMod(P[2], p);\r\n        Px = mulmod(P[0], mulmod(Px, Px, p), p);\r\n\r\n        return Px % n == rs[0];\r\n    }\r\n}"
    },
    "contracts/dnssec-oracle/algorithms/DummyAlgorithm.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"./Algorithm.sol\";\r\n\r\n/**\r\n* @dev Implements a dummy DNSSEC (signing) algorithm that approves all\r\n*      signatures, for testing.\r\n*/\r\ncontract DummyAlgorithm is Algorithm {\r\n    function verify(bytes calldata, bytes calldata, bytes calldata) external override view returns (bool) { return true; }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/digests/DummyDigest.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"./Digest.sol\";\r\n\r\n/**\r\n* @dev Implements a dummy DNSSEC digest that approves all hashes, for testing.\r\n*/\r\ncontract DummyDigest is Digest {\r\n    function verify(bytes calldata, bytes calldata) external override pure returns (bool) { return true; }\r\n}\r\n"
    },
    "contracts/dnsregistrar/SimplePublicSuffixList.sol": {
      "content": "pragma solidity ^0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../root/Ownable.sol\";\r\nimport \"./PublicSuffixList.sol\";\r\n\r\ncontract SimplePublicSuffixList is PublicSuffixList, Ownable {\r\n    mapping(bytes=>bool) suffixes;\r\n\r\n    function addPublicSuffixes(bytes[] memory names) public onlyOwner {\r\n        for(uint i = 0; i < names.length; i++) {\r\n            suffixes[names[i]] = true;\r\n        }\r\n    }\r\n\r\n    function isPublicSuffix(bytes calldata name) external override view returns(bool) {\r\n        return suffixes[name];\r\n    }\r\n}\r\n"
    },
    "contracts/root/Ownable.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    modifier onlyOwner {\r\n        require(isOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function isOwner(address addr) public view returns (bool) {\r\n        return owner == addr;\r\n    }\r\n}\r\n"
    },
    "contracts/registry/ReverseRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nimport \"./ENS.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../root/Controllable.sol\";\r\n\r\nabstract contract NameResolver {\r\n    function setName(bytes32 node, string memory name) public virtual;\r\n}\r\n\r\nbytes32 constant lookup = 0x3031323334353637383961626364656600000000000000000000000000000000;\r\n\r\nbytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\r\n\r\n// namehash('addr.reverse')\r\n\r\ncontract ReverseRegistrar is Ownable, Controllable {\r\n    ENS public ens;\r\n    NameResolver public defaultResolver;\r\n\r\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param ensAddr The address of the ENS registry.\r\n     * @param resolverAddr The address of the default reverse resolver.\r\n     */\r\n    constructor(ENS ensAddr, NameResolver resolverAddr) {\r\n        ens = ensAddr;\r\n        defaultResolver = resolverAddr;\r\n\r\n        // Assign ownership of the reverse record to our deployer\r\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\r\n            ens.owner(ADDR_REVERSE_NODE)\r\n        );\r\n        if (address(oldRegistrar) != address(0x0)) {\r\n            oldRegistrar.claim(msg.sender);\r\n        }\r\n    }\r\n\r\n    modifier authorised(address addr) {\r\n        require(\r\n            addr == msg.sender ||\r\n                controllers[msg.sender] ||\r\n                ens.isApprovedForAll(addr, msg.sender) ||\r\n                ownsContract(addr),\r\n            \"Caller is not a controller or authorised by address or the address itself\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the reverse ENS record associated with the\r\n     *      calling account.\r\n     * @param owner The address to set as the owner of the reverse record in ENS.\r\n     * @return The ENS node hash of the reverse record.\r\n     */\r\n    function claim(address owner) public returns (bytes32) {\r\n        return _claimWithResolver(msg.sender, owner, address(0x0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the reverse ENS record associated with the\r\n     *      calling account.\r\n     * @param addr The reverse record to set\r\n     * @param owner The address to set as the owner of the reverse record in ENS.\r\n     * @return The ENS node hash of the reverse record.\r\n     */\r\n    function claimForAddr(address addr, address owner)\r\n        public\r\n        authorised(addr)\r\n        returns (bytes32)\r\n    {\r\n        return _claimWithResolver(addr, owner, address(0x0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the reverse ENS record associated with the\r\n     *      calling account.\r\n     * @param owner The address to set as the owner of the reverse record in ENS.\r\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\r\n     * @return The ENS node hash of the reverse record.\r\n     */\r\n    function claimWithResolver(address owner, address resolver)\r\n        public\r\n        returns (bytes32)\r\n    {\r\n        return _claimWithResolver(msg.sender, owner, resolver);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the reverse ENS record specified with the\r\n     *      address provided\r\n     * @param addr The reverse record to set\r\n     * @param owner The address to set as the owner of the reverse record in ENS.\r\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\r\n     * @return The ENS node hash of the reverse record.\r\n     */\r\n    function claimWithResolverForAddr(\r\n        address addr,\r\n        address owner,\r\n        address resolver\r\n    ) public authorised(addr) returns (bytes32) {\r\n        return _claimWithResolver(addr, owner, resolver);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the `name()` record for the reverse ENS record associated with\r\n     * the calling account. First updates the resolver to the default reverse\r\n     * resolver if necessary.\r\n     * @param name The name to set for this address.\r\n     * @return The ENS node hash of the reverse record.\r\n     */\r\n    function setName(string memory name) public returns (bytes32) {\r\n        bytes32 node = _claimWithResolver(\r\n            msg.sender,\r\n            address(this),\r\n            address(defaultResolver)\r\n        );\r\n        defaultResolver.setName(node, name);\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the `name()` record for the reverse ENS record associated with\r\n     * the account provided. First updates the resolver to the default reverse\r\n     * resolver if necessary.\r\n     * Only callable by controllers and authorised users\r\n     * @param addr The reverse record to set\r\n     * @param owner The owner of the reverse node\r\n     * @param name The name to set for this address.\r\n     * @return The ENS node hash of the reverse record.\r\n     */\r\n    function setNameForAddr(\r\n        address addr,\r\n        address owner,\r\n        string memory name\r\n    ) public authorised(addr) returns (bytes32) {\r\n        bytes32 node = _claimWithResolver(\r\n            addr,\r\n            address(this),\r\n            address(defaultResolver)\r\n        );\r\n        defaultResolver.setName(node, name);\r\n        ens.setSubnodeOwner(ADDR_REVERSE_NODE, sha3HexAddress(addr), owner);\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the node hash for a given account's reverse records.\r\n     * @param addr The address to hash\r\n     * @return The ENS node hash.\r\n     */\r\n    function node(address addr) public pure returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev An optimised function to compute the sha3 of the lower-case\r\n     *      hexadecimal representation of an Ethereum address.\r\n     * @param addr The address to hash\r\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\r\n     *         input address.\r\n     */\r\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\r\n        assembly {\r\n            for {\r\n                let i := 40\r\n            } gt(i, 0) {\r\n\r\n            } {\r\n                i := sub(i, 1)\r\n                mstore8(i, byte(and(addr, 0xf), lookup))\r\n                addr := div(addr, 0x10)\r\n                i := sub(i, 1)\r\n                mstore8(i, byte(and(addr, 0xf), lookup))\r\n                addr := div(addr, 0x10)\r\n            }\r\n\r\n            ret := keccak256(0, 40)\r\n        }\r\n    }\r\n\r\n    /* Internal functions */\r\n\r\n    function _claimWithResolver(\r\n        address addr,\r\n        address owner,\r\n        address resolver\r\n    ) internal returns (bytes32) {\r\n        bytes32 label = sha3HexAddress(addr);\r\n        bytes32 node = keccak256(abi.encodePacked(ADDR_REVERSE_NODE, label));\r\n        address currentResolver = ens.resolver(node);\r\n        bool shouldUpdateResolver = (resolver != address(0x0) &&\r\n            resolver != currentResolver);\r\n        address newResolver = shouldUpdateResolver ? resolver : currentResolver;\r\n\r\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, label, owner, newResolver, 0);\r\n\r\n        emit ReverseClaimed(addr, node);\r\n\r\n        return node;\r\n    }\r\n\r\n    function ownsContract(address addr) internal view returns (bool) {\r\n        try Ownable(addr).owner() returns (address owner) {\r\n            return owner == msg.sender;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/DefaultReverseResolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nimport \"../registry/ENS.sol\";\r\nimport \"../registry/ReverseRegistrar.sol\";\r\n\r\n/**\r\n * @dev Provides a default implementation of a resolver for reverse records,\r\n * which permits only the owner to update it.\r\n */\r\ncontract DefaultReverseResolver {\r\n    // namehash('addr.reverse')\r\n    bytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\r\n\r\n    ENS public ens;\r\n    mapping (bytes32 => string) public name;\r\n\r\n    /**\r\n     * @dev Only permits calls by the reverse registrar.\r\n     * @param node The node permission is required for.\r\n     */\r\n    modifier onlyOwner(bytes32 node) {\r\n        require(msg.sender == ens.owner(node));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param ensAddr The address of the ENS registry.\r\n     */\r\n    constructor(ENS ensAddr) {\r\n        ens = ensAddr;\r\n\r\n        // Assign ownership of the reverse record to our deployer\r\n        ReverseRegistrar registrar = ReverseRegistrar(ens.owner(ADDR_REVERSE_NODE));\r\n        if (address(registrar) != address(0x0)) {\r\n            registrar.claim(msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the name for a node.\r\n     * @param node The node to update.\r\n     * @param _name The name to set.\r\n     */\r\n    function setName(bytes32 node, string memory _name) public onlyOwner(node) {\r\n        name[node] = _name;\r\n    }\r\n}\r\n"
    },
    "contracts/ethregistrar/StablePriceOracle.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nimport \"./PriceOracle.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./StringUtils.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ninterface AggregatorInterface {\r\n  function latestAnswer() external view returns (int256);\r\n}\r\n\r\n\r\n// StablePriceOracle sets a price in USD, based on an oracle.\r\ncontract StablePriceOracle is Ownable, PriceOracle {\r\n    using SafeMath for *;\r\n    using StringUtils for *;\r\n\r\n    // Rent in base price units by length. Element 0 is for 1-length names, and so on.\r\n    uint[] public rentPrices;\r\n\r\n    // Oracle address\r\n    AggregatorInterface public usdOracle;\r\n\r\n    event OracleChanged(address oracle);\r\n\r\n    event RentPriceChanged(uint[] prices);\r\n\r\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n    bytes4 constant private ORACLE_ID = bytes4(keccak256(\"price(string,uint256,uint256)\") ^ keccak256(\"premium(string,uint256,uint256)\"));\r\n\r\n    constructor(AggregatorInterface _usdOracle, uint[] memory _rentPrices) public {\r\n        usdOracle = _usdOracle;\r\n        setPrices(_rentPrices);\r\n    }\r\n\r\n    function price(string calldata name, uint expires, uint duration) external view override returns(uint) {\r\n        uint len = name.strlen();\r\n        if(len > rentPrices.length) {\r\n            len = rentPrices.length;\r\n        }\r\n        require(len > 0);\r\n        \r\n        uint basePrice = rentPrices[len - 1].mul(duration);\r\n        basePrice = basePrice.add(_premium(name, expires, duration));\r\n\r\n        return attoUSDToWei(basePrice);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets rent prices.\r\n     * @param _rentPrices The price array. Each element corresponds to a specific\r\n     *                    name length; names longer than the length of the array\r\n     *                    default to the price of the last element. Values are\r\n     *                    in base price units, equal to one attodollar (1e-18\r\n     *                    dollar) each.\r\n     */\r\n    function setPrices(uint[] memory _rentPrices) public onlyOwner {\r\n        rentPrices = _rentPrices;\r\n        emit RentPriceChanged(_rentPrices);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the price oracle address\r\n     * @param _usdOracle The address of the price oracle to use.\r\n     */\r\n    function setOracle(AggregatorInterface _usdOracle) public onlyOwner {\r\n        usdOracle = _usdOracle;\r\n        emit OracleChanged(address(_usdOracle));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the pricing premium in wei.\r\n     */\r\n    function premium(string calldata name, uint expires, uint duration) external view returns(uint) {\r\n        return attoUSDToWei(_premium(name, expires, duration));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the pricing premium in internal base units.\r\n     */\r\n    function _premium(string memory name, uint expires, uint duration) virtual internal view returns(uint) {\r\n        return 0;\r\n    }\r\n\r\n    function attoUSDToWei(uint amount) internal view returns(uint) {\r\n        uint ethPrice = uint(usdOracle.latestAnswer());\r\n        return amount.mul(1e8).div(ethPrice);\r\n    }\r\n\r\n    function weiToAttoUSD(uint amount) internal view returns(uint) {\r\n        uint ethPrice = uint(usdOracle.latestAnswer());\r\n        return amount.mul(ethPrice).div(1e8);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public view virtual returns (bool) {\r\n        return interfaceID == INTERFACE_META_ID || interfaceID == ORACLE_ID;\r\n    }\r\n}\r\n"
    },
    "contracts/ethregistrar/SafeMath.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n"
    },
    "contracts/ethregistrar/LinearPremiumPriceOracle.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./StablePriceOracle.sol\";\r\n\r\ncontract LinearPremiumPriceOracle is StablePriceOracle {\r\n    using SafeMath for *;\r\n\r\n    uint GRACE_PERIOD = 90 days;\r\n\r\n    uint public initialPremium;\r\n    uint public premiumDecreaseRate;\r\n\r\n    bytes4 constant private TIME_UNTIL_PREMIUM_ID = bytes4(keccak256(\"timeUntilPremium(uint,uint\"));\r\n\r\n    constructor(AggregatorInterface _usdOracle, uint[] memory _rentPrices, uint _initialPremium, uint _premiumDecreaseRate) public\r\n        StablePriceOracle(_usdOracle, _rentPrices)\r\n    {\r\n        initialPremium = _initialPremium;\r\n        premiumDecreaseRate = _premiumDecreaseRate;\r\n    }\r\n\r\n    function _premium(string memory name, uint expires, uint /*duration*/) override internal view returns(uint) {\r\n        expires = expires.add(GRACE_PERIOD);\r\n        if(expires > block.timestamp) {\r\n            // No premium for renewals\r\n            return 0;\r\n        }\r\n\r\n        // Calculate the discount off the maximum premium\r\n        uint discount = premiumDecreaseRate.mul(block.timestamp.sub(expires));\r\n\r\n        // If we've run out the premium period, return 0.\r\n        if(discount > initialPremium) {\r\n            return 0;\r\n        }\r\n        \r\n        return initialPremium - discount;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the timestamp at which a name with the specified expiry date will have\r\n     *      the specified re-registration price premium.\r\n     * @param expires The timestamp at which the name expires.\r\n     * @param amount The amount, in wei, the caller is willing to pay\r\n     * @return The timestamp at which the premium for this domain will be `amount`.\r\n     */\r\n    function timeUntilPremium(uint expires, uint amount) external view returns(uint) {\r\n        amount = weiToAttoUSD(amount);\r\n        require(amount <= initialPremium);\r\n\r\n        expires = expires.add(GRACE_PERIOD);\r\n\r\n        uint discount = initialPremium.sub(amount);\r\n        uint duration = discount.div(premiumDecreaseRate);\r\n        return expires.add(duration);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\r\n        return (interfaceID == TIME_UNTIL_PREMIUM_ID) || super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/registry/TestRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nimport \"./ENS.sol\";\r\n\r\n/**\r\n * A registrar that allocates subdomains to the first person to claim them, but\r\n * expires registrations a fixed period after they're initially claimed.\r\n */\r\ncontract TestRegistrar {\r\n    uint constant registrationPeriod = 4 weeks;\r\n\r\n    ENS public ens;\r\n    bytes32 public rootNode;\r\n    mapping (bytes32 => uint) public expiryTimes;\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param ensAddr The address of the ENS registry.\r\n     * @param node The node that this registrar administers.\r\n     */\r\n    constructor(ENS ensAddr, bytes32 node) public {\r\n        ens = ensAddr;\r\n        rootNode = node;\r\n    }\r\n\r\n    /**\r\n     * Register a name that's not currently registered\r\n     * @param label The hash of the label to register.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function register(bytes32 label, address owner) public {\r\n        require(expiryTimes[label] < block.timestamp);\r\n\r\n        expiryTimes[label] = block.timestamp + registrationPeriod;\r\n        ens.setSubnodeOwner(rootNode, label, owner);\r\n    }\r\n}\r\n"
    },
    "contracts/registry/FIFSRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nimport \"./ENS.sol\";\r\n\r\n/**\r\n * A registrar that allocates subdomains to the first person to claim them.\r\n */\r\ncontract FIFSRegistrar {\r\n    ENS ens;\r\n    bytes32 rootNode;\r\n\r\n    modifier only_owner(bytes32 label) {\r\n        address currentOwner = ens.owner(keccak256(abi.encodePacked(rootNode, label)));\r\n        require(currentOwner == address(0x0) || currentOwner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param ensAddr The address of the ENS registry.\r\n     * @param node The node that this registrar administers.\r\n     */\r\n    constructor(ENS ensAddr, bytes32 node) public {\r\n        ens = ensAddr;\r\n        rootNode = node;\r\n    }\r\n\r\n    /**\r\n     * Register a name, or change the owner of an existing registration.\r\n     * @param label The hash of the label to register.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function register(bytes32 label, address owner) public only_owner(label) {\r\n        ens.setSubnodeOwner(rootNode, label, owner);\r\n    }\r\n}\r\n"
    },
    "contracts/dnsregistrar/mocks/DummyDnsRegistrarDNSSEC.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\ncontract DummyDNSSEC {\r\n    uint16 expectedType;\r\n    bytes expectedName;\r\n    uint32 inception;\r\n    uint64 inserted;\r\n    bytes20 hash;\r\n\r\n    function setData(uint16 _expectedType, bytes memory _expectedName, uint32 _inception, uint64 _inserted, bytes memory _proof) public {\r\n        expectedType = _expectedType;\r\n        expectedName = _expectedName;\r\n        inception = _inception;\r\n        inserted = _inserted;\r\n        if(_proof.length != 0) {\r\n            hash = bytes20(keccak256(_proof));\r\n        }\r\n    }\r\n\r\n    function rrdata(uint16 dnstype, bytes memory name) public view returns (uint32, uint64, bytes20) {\r\n        require(dnstype == expectedType);\r\n        require(keccak256(name) == keccak256(expectedName));\r\n        return (inception, inserted, hash);\r\n    }\r\n}\r\n"
    },
    "contracts/ethregistrar/DummyOracle.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\ncontract DummyOracle {\r\n    int value;\r\n\r\n    constructor(int _value) public {\r\n        set(_value);\r\n    }\r\n\r\n    function set(int _value) public {\r\n        value = _value;\r\n    }\r\n\r\n    function latestAnswer() public view returns(int256) {\r\n        return value;\r\n    }\r\n}\r\n"
    },
    "contracts/ethregistrar/mocks/DummyProxyRegistry.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\ncontract DummyProxyRegistry {\r\n    address target;\r\n\r\n    constructor(address _target) public {\r\n        target = _target;\r\n    }\r\n\r\n    function proxies(address a) external view returns(address) {\r\n        return target;\r\n    }\r\n}\r\n"
    },
    "contracts/ethregistrar/TestResolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\n/**\r\n * @dev A test resolver implementation\r\n */\r\ncontract TestResolver {\r\n    mapping (bytes32 => address) addresses;\r\n\r\n    constructor() public {\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\r\n        return interfaceID == 0x01ffc9a7 || interfaceID == 0x3b3b57de;\r\n    }\r\n\r\n    function addr(bytes32 node) public view returns (address) {\r\n        return addresses[node];\r\n    }\r\n\r\n    function setAddr(bytes32 node, address addr) public {\r\n        addresses[node] = addr;\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/mocks/DummyNameWrapper.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\n/**\r\n* @dev Implements a dummy NameWrapper which returns the caller's address\r\n*/\r\ncontract DummyNameWrapper {\r\n    function ownerOf(uint256 /* id */) public view returns (address) {\r\n        return tx.origin;\r\n    }\r\n}\r\n"
    },
    "test/registry/mocks/DummyResolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\ncontract DummyResolver {\r\n\r\n    mapping (bytes32 => string) public name;\r\n\r\n    function setName(bytes32 node, string memory _name) public {\r\n        name[node] = _name;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}