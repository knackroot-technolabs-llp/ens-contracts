{
  "language": "Solidity",
  "sources": {
    "contracts/root/Root.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"../registry/ENS.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./Controllable.sol\";\r\nimport \"../decentraname/IDecentraNameController.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\r\n\r\n// TODO-review : I have extended from ERC721Holder to make this contract as valid NFT owner\r\ncontract Root is Ownable, Controllable, ERC721Holder {\r\n    bytes32 public constant rootNode = bytes32(0);\r\n    uint public constant GRACE_PERIOD = 90 days;\r\n\r\n    bytes4 private constant INTERFACE_META_ID =\r\n        bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n    // bytes4 constant private RECLAIM_ID = bytes4(keccak256(\"reclaim(uint256,address)\"));\r\n\r\n    ENS public ens;\r\n\r\n    // The dweb NFT token\r\n    IDecentraNameController public decentraNameController;\r\n\r\n    // TODO: set expiry of root domain as infinity\r\n    // A map of expiry times\r\n    mapping(uint256=>uint) expiries;\r\n\r\n    // TODO: does locked makes sense now?\r\n    mapping(bytes32 => bool) public locked;\r\n\r\n    event TLDLocked(bytes32 indexed label);\r\n    event NameMigrated(uint256 indexed id, address indexed owner, uint expires);\r\n    event NameRegistered(uint256 indexed id, address indexed owner, uint expires);\r\n    event NameRenewed(uint256 indexed id, uint expires);\r\n\r\n    constructor(ENS _ens, IDecentraNameController _decentraNameController) {\r\n        ens = _ens;\r\n        decentraNameController =  _decentraNameController;\r\n    }\r\n\r\n    function setSubnodeOwner(bytes32 label, address owner)\r\n        external\r\n        onlyController\r\n    {\r\n        require(!locked[label]);\r\n        ens.setSubnodeOwner(rootNode, label, owner);\r\n    }\r\n\r\n    function setResolver(address resolver) external onlyOwner {\r\n        ens.setResolver(rootNode, resolver);\r\n    }\r\n\r\n    function lock(bytes32 label) external onlyOwner {\r\n        emit TLDLocked(label);\r\n        locked[label] = true;\r\n    }\r\n\r\n    function setRootDomainOwner() external onlyOwner {\r\n        decentraNameController.mintTokenForTLD(address(this), uint256(rootNode));\r\n    }\r\n\r\n    // TODO: add transfer method to transfer ownership of root node(NFT) in decentraname \r\n\r\n    // Returns the expiration timestamp of the specified id.\r\n    function nameExpires(uint256 id) external view returns(uint) {\r\n        return expiries[id];\r\n    }\r\n\r\n    // Returns true iff the specified name is available for registration.\r\n    function available(uint256 id) public view returns(bool) {\r\n        // Not available if it's registered here or in its grace period.\r\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Register a name.\r\n     * @param id The token ID (keccak256 of the label).\r\n     * @param owner The address that should own the registration.\r\n     * @param duration Duration in seconds for the registration.\r\n     */\r\n\r\n    function register(uint256 id, address owner, uint duration) external onlyController returns(uint) {\r\n        require(available(id));\r\n        require(block.timestamp + duration + GRACE_PERIOD > block.timestamp + GRACE_PERIOD); // Prevent future overflow\r\n\r\n        expiries[id] = block.timestamp + duration;\r\n        if(decentraNameController.existsToken(id)) {\r\n            // Name was previously owned, and expired\r\n            decentraNameController.burnToken(id);\r\n        }\r\n        decentraNameController.mintTokenForTLD(owner, id);\r\n\r\n        emit NameRegistered(id, owner, block.timestamp + duration);\r\n\r\n        return block.timestamp + duration;\r\n    }\r\n\r\n    function renew(uint256 id, uint duration) external onlyController returns(uint) {\r\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\r\n        require(expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD); // Prevent future overflow\r\n\r\n        expiries[id] += duration;\r\n        emit NameRenewed(id, expiries[id]);\r\n        return expiries[id];\r\n    }\r\n\r\n    // TODO: revisit this. we may not require reclaim as every url is now NFT\r\n    // TODO: review: removing below methods as it is no logner required. Now ownership is no longer managed in ens but in decentraName only\r\n    /**\r\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\r\n     */\r\n    // function reclaim(uint256 id, address owner) external override live {\r\n    //     require(decentraNameController.isApprovedOrOwner(msg.sender, id));\r\n    //     ens.setSubnodeOwner(baseNode, bytes32(id), owner);\r\n    // }\r\n\r\n    function supportsInterface(bytes4 interfaceID)\r\n        external\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return interfaceID == INTERFACE_META_ID;\r\n    }\r\n}\r\n"
    },
    "contracts/registry/ENS.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\ninterface ENS {\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n    // Logged when an operator is added or removed.\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual;\r\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual;\r\n    function createSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual;\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external virtual returns(bytes32);\r\n    function setResolver(bytes32 node, address resolver) external virtual;\r\n    function setOwner(bytes32 node, address owner) external virtual;\r\n    function createSubnode(bytes32 node, bytes32 label, address owner) external virtual returns(bytes32);\r\n    function setTTL(bytes32 node, uint64 ttl) external virtual;\r\n    function setApprovalForAll(address operator, bool approved) external virtual;\r\n    function owner(bytes32 node) external virtual view returns (address);\r\n    function resolver(bytes32 node) external virtual view returns (address);\r\n    function ttl(bytes32 node) external virtual view returns (uint64);\r\n    function recordExists(bytes32 node) external virtual view returns (bool);\r\n    function isApprovedForAll(address owner, address operator) external virtual view returns (bool);\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/root/Controllable.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract Controllable is Ownable {\r\n    mapping(address => bool) public controllers;\r\n\r\n    event ControllerChanged(address indexed controller, bool enabled);\r\n\r\n    modifier onlyController {\r\n        require(\r\n            controllers[msg.sender],\r\n            \"Controllable: Caller is not a controller\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setController(address controller, bool enabled) public onlyOwner {\r\n        controllers[controller] = enabled;\r\n        emit ControllerChanged(controller, enabled);\r\n    }\r\n}\r\n"
    },
    "contracts/decentraname/IDecentraNameController.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\n\r\ninterface IDecentraNameController {\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n\r\n    function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\r\n\r\n    function existsToken(uint256 tokenId) external view returns (bool);\r\n\r\n    function burnToken(uint256 tokenId) external;\r\n\r\n    function mintToken(address owner, uint256 id) external;\r\n\r\n    function mintTokenForTLD(address owner, uint256 id) external;\r\n\r\n    function transferToken(address to, uint256 id) external;\r\n}"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/ethregistrar/RootRegistrarController.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nimport \"./PriceOracle.sol\";\r\nimport \"../root/Root.sol\";\r\nimport \"./StringUtils.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../resolvers/Resolver.sol\";\r\n\r\n/**\r\n * @dev A registrar controller for registering and renewing names at fixed cost.\r\n */\r\ncontract RootRegistrarController is Ownable {\r\n    using StringUtils for *;\r\n\r\n    uint constant public MIN_REGISTRATION_DURATION = 28 days;\r\n\r\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n    bytes4 constant private COMMITMENT_CONTROLLER_ID = bytes4(\r\n        keccak256(\"rentPrice(string,uint256)\") ^\r\n        keccak256(\"available(string)\") ^\r\n        keccak256(\"makeCommitment(string,address,bytes32)\") ^\r\n        keccak256(\"commit(bytes32)\") ^\r\n        keccak256(\"register(string,address,uint256,bytes32)\") ^\r\n        keccak256(\"renew(string,uint256)\")\r\n    );\r\n\r\n    bytes4 constant private COMMITMENT_WITH_CONFIG_CONTROLLER_ID = bytes4(\r\n        keccak256(\"registerWithConfig(string,address,uint256,bytes32,address,address)\") ^\r\n        keccak256(\"makeCommitmentWithConfig(string,address,bytes32,address,address)\")\r\n    );\r\n\r\n    Root root;\r\n    PriceOracle prices;\r\n    uint public minCommitmentAge;\r\n    uint public maxCommitmentAge;\r\n\r\n    mapping(bytes32=>uint) public commitments;\r\n\r\n    event NameRegistered(string name, bytes32 indexed label, address indexed owner, uint cost, uint expires);\r\n    event NameRenewed(string name, bytes32 indexed label, uint cost, uint expires);\r\n    event NewPriceOracle(address indexed oracle);\r\n\r\n    constructor(Root _root, PriceOracle _prices, uint _minCommitmentAge, uint _maxCommitmentAge) {\r\n        require(_maxCommitmentAge > _minCommitmentAge);\r\n\r\n        root = _root;\r\n        prices = _prices;\r\n        minCommitmentAge = _minCommitmentAge;\r\n        maxCommitmentAge = _maxCommitmentAge;\r\n    }\r\n\r\n    function rentPrice(string memory name, uint duration) view public returns(uint) {\r\n        bytes32 label = keccak256(bytes(name));\r\n        bytes32 tokenId = keccak256(abi.encodePacked(root.rootNode(), label));\r\n        return prices.price(name, root.nameExpires(uint256(tokenId)), duration);\r\n    }\r\n\r\n    function valid(string memory name) public pure returns(bool) {\r\n        return name.strlen() >= 3;\r\n    }\r\n\r\n    function available(string memory name) public view returns(bool) {\r\n        bytes32 label = keccak256(bytes(name));\r\n        bytes32 tokenId = keccak256(abi.encodePacked(root.rootNode(), label));\r\n        return valid(name) && root.available(uint256(tokenId));\r\n    }\r\n\r\n    function makeCommitment(string memory name, address owner, bytes32 secret) pure public returns(bytes32) {\r\n        return makeCommitmentWithConfig(name, owner, secret, address(0), address(0));\r\n    }\r\n\r\n    function makeCommitmentWithConfig(string memory name, address owner, bytes32 secret, address resolver, address addr) pure public returns(bytes32) {\r\n        bytes32 label = keccak256(bytes(name));\r\n        if (resolver == address(0) && addr == address(0)) {\r\n            return keccak256(abi.encodePacked(label, owner, secret));\r\n        }\r\n        require(resolver != address(0));\r\n        return keccak256(abi.encodePacked(label, owner, resolver, addr, secret));\r\n    }\r\n\r\n    function commit(bytes32 commitment) public {\r\n        require(commitments[commitment] + maxCommitmentAge < block.timestamp);\r\n        commitments[commitment] = block.timestamp;\r\n    }\r\n\r\n    function register(string calldata name, address owner, uint duration, bytes32 secret) external payable {\r\n      registerWithConfig(name, owner, duration, secret, address(0), address(0));\r\n    }\r\n\r\n    function registerWithConfig(string memory name, address owner, uint duration, bytes32 secret, address resolver, address addr) public payable {\r\n        // TODO: name has to be TLD. put check for this\r\n        bytes32 commitment = makeCommitmentWithConfig(name, owner, secret, resolver, addr);\r\n        uint cost = _consumeCommitment(name, duration, commitment);\r\n\r\n        bytes32 label = keccak256(bytes(name));\r\n        // The nodehash of this label\r\n        bytes32 tokenId = keccak256(abi.encodePacked(root.rootNode(), label));\r\n\r\n        uint expires;\r\n        // TODO: Future release : skipping setting revords for now\r\n        // ---\r\n        // if(resolver != address(0)) {\r\n        //     // Set this contract as the (temporary) owner, giving it\r\n        //     // permission to set up the resolver.\r\n        //     expires = root.register(uint256(tokenId), address(this), duration);\r\n\r\n        //     // Set the resolver\r\n        //     root.ens().setResolver(tokenId, resolver);\r\n\r\n        //     // Configure the resolver\r\n        //     if (addr != address(0)) {\r\n        //         Resolver(resolver).setAddr(tokenId, addr);\r\n        //     }\r\n\r\n        //     // Now transfer full ownership to the expeceted owner\r\n        //     //base.reclaim(tokenId, owner);\r\n            \r\n        //     //base.transferFrom(address(this), owner, tokenId);\r\n        //     // TODO: can we improve below?\r\n        //     root.decentraNameController().decentraName().safeTransferFrom(address(this), owner, uint256(tokenId));\r\n        // } else \r\n        // ---\r\n        {\r\n            require(addr == address(0));\r\n            expires = root.register(uint256(tokenId), owner, duration);\r\n        }\r\n\r\n        emit NameRegistered(name, label, owner, cost, expires);\r\n\r\n        // Refund any extra payment\r\n        if(msg.value > cost) {\r\n            payable(msg.sender).transfer(msg.value - cost);\r\n        }\r\n    }\r\n\r\n    function renew(string calldata name, uint duration) external payable {\r\n        uint cost = rentPrice(name, duration);\r\n        require(msg.value >= cost);\r\n\r\n        bytes32 label = keccak256(bytes(name));\r\n        bytes32 tokenId = keccak256(abi.encodePacked(root.rootNode(), label));\r\n        uint expires = root.renew(uint256(tokenId), duration);\r\n\r\n        if(msg.value > cost) {\r\n            payable(msg.sender).transfer(msg.value - cost);\r\n        }\r\n\r\n        emit NameRenewed(name, label, cost, expires);\r\n    }\r\n\r\n    function setPriceOracle(PriceOracle _prices) public onlyOwner {\r\n        prices = _prices;\r\n        emit NewPriceOracle(address(prices));\r\n    }\r\n\r\n    function setCommitmentAges(uint _minCommitmentAge, uint _maxCommitmentAge) public onlyOwner {\r\n        minCommitmentAge = _minCommitmentAge;\r\n        maxCommitmentAge = _maxCommitmentAge;\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        payable(msg.sender).transfer(address(this).balance);        \r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\r\n        return interfaceID == INTERFACE_META_ID ||\r\n               interfaceID == COMMITMENT_CONTROLLER_ID ||\r\n               interfaceID == COMMITMENT_WITH_CONFIG_CONTROLLER_ID;\r\n    }\r\n\r\n    function _consumeCommitment(string memory name, uint duration, bytes32 commitment) internal returns (uint256) {\r\n        // Require a valid commitment\r\n        require(commitments[commitment] + minCommitmentAge <= block.timestamp);\r\n\r\n        // If the commitment is too old, or the name is registered, stop\r\n        require(commitments[commitment] + maxCommitmentAge > block.timestamp);\r\n        require(available(name));\r\n\r\n        delete(commitments[commitment]);\r\n\r\n        uint cost = rentPrice(name, duration);\r\n        require(duration >= MIN_REGISTRATION_DURATION);\r\n        require(msg.value >= cost);\r\n\r\n        return cost;\r\n    }\r\n}\r\n"
    },
    "contracts/ethregistrar/PriceOracle.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\ninterface PriceOracle {\r\n    /**\r\n     * @dev Returns the price to register or renew a name.\r\n     * @param name The name being registered or renewed.\r\n     * @param expires When the name presently expires (0 if this is a new registration).\r\n     * @param duration How long the name is being registered or extended for, in seconds.\r\n     * @return The price of this renewal or registration, in wei.\r\n     */\r\n    function price(string calldata name, uint expires, uint duration) external view returns(uint);\r\n}\r\n"
    },
    "contracts/ethregistrar/StringUtils.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nlibrary StringUtils {\r\n    /**\r\n     * @dev Returns the length of a given string\r\n     *\r\n     * @param s The string to measure the length of\r\n     * @return The length of the input string\r\n     */\r\n    function strlen(string memory s) internal pure returns (uint) {\r\n        uint len;\r\n        uint i = 0;\r\n        uint bytelength = bytes(s).length;\r\n        for(len = 0; i < bytelength; len++) {\r\n            bytes1 b = bytes(s)[i];\r\n            if(b < 0x80) {\r\n                i += 1;\r\n            } else if (b < 0xE0) {\r\n                i += 2;\r\n            } else if (b < 0xF0) {\r\n                i += 3;\r\n            } else if (b < 0xF8) {\r\n                i += 4;\r\n            } else if (b < 0xFC) {\r\n                i += 5;\r\n            } else {\r\n                i += 6;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n}\r\n"
    },
    "contracts/resolvers/Resolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * A generic resolver interface which includes all the functions including the ones deprecated\r\n */\r\ninterface Resolver{\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\r\n    event NameChanged(bytes32 indexed node, string name);\r\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\r\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\r\n    /* Deprecated events */\r\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\r\n\r\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);\r\n    function addr(bytes32 node) external view returns (address);\r\n    function addr(bytes32 node, uint coinType) external view returns(bytes memory);\r\n    function contenthash(bytes32 node) external view returns (bytes memory);\r\n    function dnsrr(bytes32 node) external view returns (bytes memory);\r\n    function name(bytes32 node) external view returns (string memory);\r\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\r\n    function text(bytes32 node, string calldata key) external view returns (string memory);\r\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\r\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\r\n    function setAddr(bytes32 node, address addr) external;\r\n    function setAddr(bytes32 node, uint coinType, bytes calldata a) external;\r\n    function setContenthash(bytes32 node, bytes calldata hash) external;\r\n    function setDnsrr(bytes32 node, bytes calldata data) external;\r\n    function setName(bytes32 node, string calldata _name) external;\r\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\r\n    function setText(bytes32 node, string calldata key, string calldata value) external;\r\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external;\r\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool);\r\n    function multicall(bytes[] calldata data) external returns(bytes[] memory results);\r\n\r\n    /* Deprecated functions */\r\n    function content(bytes32 node) external view returns (bytes32);\r\n    function multihash(bytes32 node) external view returns (bytes memory);\r\n    function setContent(bytes32 node, bytes32 hash) external;\r\n    function setMultihash(bytes32 node, bytes calldata hash) external;\r\n}\r\n"
    },
    "contracts/ethregistrar/BulkRenewal.sol": {
      "content": "pragma solidity >=0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../registry/ENS.sol\";\r\nimport \"./RootRegistrarController.sol\";\r\nimport \"../resolvers/Resolver.sol\";\r\n\r\ncontract BulkRenewal {\r\n    bytes32 constant private ETH_NAMEHASH = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\r\n    bytes4 constant private REGISTRAR_CONTROLLER_ID = 0x018fac06;\r\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n    bytes4 constant public BULK_RENEWAL_ID = bytes4(\r\n        keccak256(\"rentPrice(string[],uint)\") ^\r\n        keccak256(\"renewAll(string[],uint\")\r\n    );\r\n\r\n    ENS public ens;\r\n\r\n    constructor(ENS _ens) public {\r\n        ens = _ens;\r\n    }\r\n\r\n    function getController() internal view returns(RootRegistrarController) {\r\n        Resolver r = Resolver(ens.resolver(ETH_NAMEHASH));\r\n        return RootRegistrarController(r.interfaceImplementer(ETH_NAMEHASH, REGISTRAR_CONTROLLER_ID));\r\n    }\r\n\r\n    function rentPrice(string[] calldata names, uint duration) external view returns(uint total) {\r\n        RootRegistrarController controller = getController();\r\n        for(uint i = 0; i < names.length; i++) {\r\n            total += controller.rentPrice(names[i], duration);\r\n        }\r\n    }\r\n\r\n    function renewAll(string[] calldata names, uint duration) external payable {\r\n        RootRegistrarController controller = getController();\r\n        for(uint i = 0; i < names.length; i++) {\r\n            uint cost = controller.rentPrice(names[i], duration);\r\n            controller.renew{value:cost}(names[i], duration);\r\n        }\r\n        // Send any excess funds back\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\r\n         return interfaceID == INTERFACE_META_ID || interfaceID == BULK_RENEWAL_ID;\r\n    }\r\n}\r\n"
    },
    "contracts/dnsregistrar/DNSRegistrar.sol": {
      "content": "pragma solidity ^0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../dnssec-oracle/BytesUtils.sol\";\r\nimport \"../dnssec-oracle/DNSSEC.sol\";\r\nimport \"../registry/ENSRegistry.sol\";\r\nimport \"../root/Root.sol\";\r\nimport \"./DNSClaimChecker.sol\";\r\nimport \"./PublicSuffixList.sol\";\r\nimport \"../resolvers/profiles/AddrResolver.sol\";\r\n\r\ninterface IDNSRegistrar {\r\n    function claim(bytes memory name, bytes memory proof) external;\r\n    function proveAndClaim(bytes memory name, DNSSEC.RRSetWithSignature[] memory input, bytes memory proof) external;\r\n    function proveAndClaimWithResolver(bytes memory name, DNSSEC.RRSetWithSignature[] memory input, bytes memory proof, address resolver, address addr) external;\r\n}\r\n\r\n/**\r\n * @dev An ENS registrar that allows the owner of a DNS name to claim the\r\n *      corresponding name in ENS.\r\n */\r\ncontract DNSRegistrar is IDNSRegistrar {\r\n    using BytesUtils for bytes;\r\n\r\n    DNSSEC public oracle;\r\n    ENS public ens;\r\n    PublicSuffixList public suffixes;\r\n\r\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n\r\n    event Claim(bytes32 indexed node, address indexed owner, bytes dnsname);\r\n    event NewOracle(address oracle);\r\n    event NewPublicSuffixList(address suffixes);\r\n\r\n    constructor(DNSSEC _dnssec, PublicSuffixList _suffixes, ENS _ens) {\r\n        oracle = _dnssec;\r\n        emit NewOracle(address(oracle));\r\n        suffixes = _suffixes;\r\n        emit NewPublicSuffixList(address(suffixes));\r\n        ens = _ens;\r\n    }\r\n\r\n    /**\r\n     * @dev This contract's owner-only functions can be invoked by the owner of the ENS root.\r\n     */\r\n    modifier onlyOwner {\r\n        Root root = Root(ens.owner(bytes32(0)));\r\n        address owner = root.owner();\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setOracle(DNSSEC _dnssec) public onlyOwner {\r\n        oracle = _dnssec;\r\n        emit NewOracle(address(oracle));\r\n    }\r\n\r\n    function setPublicSuffixList(PublicSuffixList _suffixes) public onlyOwner {\r\n        suffixes = _suffixes;\r\n        emit NewPublicSuffixList(address(suffixes));\r\n    }\r\n\r\n    /**\r\n     * @dev Claims a name by proving ownership of its DNS equivalent.\r\n     * @param name The name to claim, in DNS wire format.\r\n     * @param proof A DNS RRSet proving ownership of the name. Must be verified\r\n     *        in the DNSSEC oracle before calling. This RRSET must contain a TXT\r\n     *        record for '_ens.' + name, with the value 'a=0x...'. Ownership of\r\n     *        the name will be transferred to the address specified in the TXT\r\n     *        record.\r\n     */\r\n    function claim(bytes memory name, bytes memory proof) public override {\r\n        (bytes32 rootNode, bytes32 labelHash, address addr) = _claim(name, proof);\r\n        ens.setSubnodeOwner(rootNode, labelHash, addr);\r\n    }\r\n\r\n    /**\r\n     * @dev Submits proofs to the DNSSEC oracle, then claims a name using those proofs.\r\n     * @param name The name to claim, in DNS wire format.\r\n     * @param input The data to be passed to the Oracle's `submitProofs` function. The last\r\n     *        proof must be the TXT record required by the registrar.\r\n     * @param proof The proof record for the first element in input.\r\n     */\r\n    function proveAndClaim(bytes memory name, DNSSEC.RRSetWithSignature[] memory input, bytes memory proof) public override {\r\n        proof = oracle.submitRRSets(input, proof);\r\n        claim(name, proof);\r\n    }\r\n\r\n    function proveAndClaimWithResolver(bytes memory name, DNSSEC.RRSetWithSignature[] memory input, bytes memory proof, address resolver, address addr) public override {\r\n        proof = oracle.submitRRSets(input, proof);\r\n        (bytes32 rootNode, bytes32 labelHash, address owner) = _claim(name, proof);\r\n        require(msg.sender == owner, \"Only owner can call proveAndClaimWithResolver\");\r\n        if(addr != address(0)) {\r\n            require(resolver != address(0), \"Cannot set addr if resolver is not set\");\r\n            // Set ourselves as the owner so we can set a record on the resolver\r\n            ens.setSubnodeRecord(rootNode, labelHash, address(this), resolver, 0);\r\n            bytes32 node = keccak256(abi.encodePacked(rootNode, labelHash));\r\n            // Set the resolver record\r\n            AddrResolver(resolver).setAddr(node, addr);\r\n            // Transfer the record to the owner\r\n            ens.setOwner(node, owner);\r\n        } else {\r\n            ens.setSubnodeRecord(rootNode, labelHash, owner, resolver, 0);\r\n        }\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\r\n        return interfaceID == INTERFACE_META_ID ||\r\n               interfaceID == type(IDNSRegistrar).interfaceId;\r\n    }\r\n\r\n    function _claim(bytes memory name, bytes memory proof) internal returns(bytes32 rootNode, bytes32 labelHash, address addr) {\r\n        // Get the first label\r\n        uint labelLen = name.readUint8(0);\r\n        labelHash = name.keccak(1, labelLen);\r\n\r\n        // Parent name must be in the public suffix list.\r\n        bytes memory parentName = name.substring(labelLen + 1, name.length - labelLen - 1);\r\n        require(suffixes.isPublicSuffix(parentName), \"Parent name must be a public suffix\");\r\n\r\n        // Make sure the parent name is enabled\r\n        rootNode = enableNode(parentName, 0);\r\n\r\n        (addr,) = DNSClaimChecker.getOwnerAddress(oracle, name, proof);\r\n\r\n        emit Claim(keccak256(abi.encodePacked(rootNode, labelHash)), addr, name);\r\n    }\r\n\r\n    function enableNode(bytes memory domain, uint offset) internal returns(bytes32 node) {\r\n        uint len = domain.readUint8(offset);\r\n        if(len == 0) {\r\n            return bytes32(0);\r\n        }\r\n\r\n        bytes32 parentNode = enableNode(domain, offset + len + 1);\r\n        bytes32 label = domain.keccak(offset + 1, len);\r\n        node = keccak256(abi.encodePacked(parentNode, label));\r\n        address owner = ens.owner(node);\r\n        require(owner == address(0) || owner == address(this), \"Cannot enable a name owned by someone else\");\r\n        if(owner != address(this)) {\r\n            if(parentNode == bytes32(0)) {\r\n                Root root = Root(ens.owner(bytes32(0)));\r\n                root.setSubnodeOwner(label, address(this));\r\n            } else {\r\n                ens.setSubnodeOwner(parentNode, label, address(this));\r\n            }\r\n        }\r\n        return node;\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/BytesUtils.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nlibrary BytesUtils {\r\n    /*\r\n    * @dev Returns the keccak-256 hash of a byte range.\r\n    * @param self The byte string to hash.\r\n    * @param offset The position to start hashing at.\r\n    * @param len The number of bytes to hash.\r\n    * @return The hash of the byte range.\r\n    */\r\n    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {\r\n        require(offset + len <= self.length);\r\n        assembly {\r\n            ret := keccak256(add(add(self, 32), offset), len)\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n    * @dev Returns a positive number if `other` comes lexicographically after\r\n    *      `self`, a negative number if it comes before, or zero if the\r\n    *      contents of the two bytes are equal.\r\n    * @param self The first bytes to compare.\r\n    * @param other The second bytes to compare.\r\n    * @return The result of the comparison.\r\n    */\r\n    function compare(bytes memory self, bytes memory other) internal pure returns (int) {\r\n        return compare(self, 0, self.length, other, 0, other.length);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns a positive number if `other` comes lexicographically after\r\n    *      `self`, a negative number if it comes before, or zero if the\r\n    *      contents of the two bytes are equal. Comparison is done per-rune,\r\n    *      on unicode codepoints.\r\n    * @param self The first bytes to compare.\r\n    * @param offset The offset of self.\r\n    * @param len    The length of self.\r\n    * @param other The second bytes to compare.\r\n    * @param otheroffset The offset of the other string.\r\n    * @param otherlen    The length of the other string.\r\n    * @return The result of the comparison.\r\n    */\r\n    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {\r\n        uint shortest = len;\r\n        if (otherlen < len)\r\n        shortest = otherlen;\r\n\r\n        uint selfptr;\r\n        uint otherptr;\r\n\r\n        assembly {\r\n            selfptr := add(self, add(offset, 32))\r\n            otherptr := add(other, add(otheroffset, 32))\r\n        }\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint mask;\r\n                if (shortest > 32) {\r\n                    mask = type(uint256).max;\r\n                } else {\r\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                }\r\n                int diff = int(a & mask) - int(b & mask);\r\n                if (diff != 0)\r\n                return diff;\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n\r\n        return int(len) - int(otherlen);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the two byte ranges are equal.\r\n    * @param self The first byte range to compare.\r\n    * @param offset The offset into the first byte range.\r\n    * @param other The second byte range to compare.\r\n    * @param otherOffset The offset into the second byte range.\r\n    * @param len The number of bytes to compare\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {\r\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the two byte ranges are equal with offsets.\r\n    * @param self The first byte range to compare.\r\n    * @param offset The offset into the first byte range.\r\n    * @param other The second byte range to compare.\r\n    * @param otherOffset The offset into the second byte range.\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {\r\n        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\r\n    }\r\n\r\n    /*\r\n    * @dev Compares a range of 'self' to all of 'other' and returns True iff\r\n    *      they are equal.\r\n    * @param self The first byte range to compare.\r\n    * @param offset The offset into the first byte range.\r\n    * @param other The second byte range to compare.\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {\r\n        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the two byte ranges are equal.\r\n    * @param self The first byte range to compare.\r\n    * @param other The second byte range to compare.\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {\r\n        return self.length == other.length && equals(self, 0, other, 0, self.length);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 8-bit number at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 8 bits of the string, interpreted as an integer.\r\n    */\r\n    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {\r\n        return uint8(self[idx]);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 16-bit number at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 16 bits of the string, interpreted as an integer.\r\n    */\r\n    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {\r\n        require(idx + 2 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 32-bit number at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 32 bits of the string, interpreted as an integer.\r\n    */\r\n    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {\r\n        require(idx + 4 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 32 byte value at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 32 bytes of the string.\r\n    */\r\n    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {\r\n        require(idx + 32 <= self.length);\r\n        assembly {\r\n            ret := mload(add(add(self, 32), idx))\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 32 byte value at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 32 bytes of the string.\r\n    */\r\n    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {\r\n        require(idx + 20 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the n byte value at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes.\r\n    * @param len The number of bytes.\r\n    * @return The specified 32 bytes of the string.\r\n    */\r\n    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {\r\n        require(len <= 32);\r\n        require(idx + len <= self.length);\r\n        assembly {\r\n            let mask := not(sub(exp(256, sub(32, len)), 1))\r\n            ret := and(mload(add(add(self, 32), idx)),  mask)\r\n        }\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        unchecked {\r\n            uint mask = (256 ** (32 - len)) - 1;\r\n            assembly {\r\n                let srcpart := and(mload(src), not(mask))\r\n                let destpart := and(mload(dest), mask)\r\n                mstore(dest, or(destpart, srcpart))\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Copies a substring into a new byte string.\r\n    * @param self The byte string to copy from.\r\n    * @param offset The offset to start copying at.\r\n    * @param len The number of bytes to copy.\r\n    */\r\n    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {\r\n        require(offset + len <= self.length);\r\n\r\n        bytes memory ret = new bytes(len);\r\n        uint dest;\r\n        uint src;\r\n\r\n        assembly {\r\n            dest := add(ret, 32)\r\n            src := add(add(self, 32), offset)\r\n        }\r\n        memcpy(dest, src, len);\r\n\r\n        return ret;\r\n    }\r\n\r\n    // Maps characters from 0x30 to 0x7A to their base32 values.\r\n    // 0xFF represents invalid characters in that range.\r\n    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';\r\n\r\n    /**\r\n     * @dev Decodes unpadded base32 data of up to one word in length.\r\n     * @param self The data to decode.\r\n     * @param off Offset into the string to start at.\r\n     * @param len Number of characters to decode.\r\n     * @return The decoded data, left aligned.\r\n     */\r\n    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {\r\n        require(len <= 52);\r\n\r\n        uint ret = 0;\r\n        uint8 decoded;\r\n        for(uint i = 0; i < len; i++) {\r\n            bytes1 char = self[off + i];\r\n            require(char >= 0x30 && char <= 0x7A);\r\n            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);\r\n            require(decoded <= 0x20);\r\n            if(i == len - 1) {\r\n                break;\r\n            }\r\n            ret = (ret << 5) | decoded;\r\n        }\r\n\r\n        uint bitlen = len * 5;\r\n        if(len % 8 == 0) {\r\n            // Multiple of 8 characters, no padding\r\n            ret = (ret << 5) | decoded;\r\n        } else if(len % 8 == 2) {\r\n            // Two extra characters - 1 byte\r\n            ret = (ret << 3) | (decoded >> 2);\r\n            bitlen -= 2;\r\n        } else if(len % 8 == 4) {\r\n            // Four extra characters - 2 bytes\r\n            ret = (ret << 1) | (decoded >> 4);\r\n            bitlen -= 4;\r\n        } else if(len % 8 == 5) {\r\n            // Five extra characters - 3 bytes\r\n            ret = (ret << 4) | (decoded >> 1);\r\n            bitlen -= 1;\r\n        } else if(len % 8 == 7) {\r\n            // Seven extra characters - 4 bytes\r\n            ret = (ret << 2) | (decoded >> 3);\r\n            bitlen -= 3;\r\n        } else {\r\n            revert();\r\n        }\r\n\r\n        return bytes32(ret << (256 - bitlen));\r\n    }\r\n}"
    },
    "contracts/dnssec-oracle/DNSSEC.sol": {
      "content": "pragma solidity ^0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\nabstract contract DNSSEC {\r\n\r\n    bytes public anchors;\r\n\r\n    struct RRSetWithSignature {\r\n        bytes rrset;\r\n        bytes sig;\r\n    }\r\n\r\n    event AlgorithmUpdated(uint8 id, address addr);\r\n    event DigestUpdated(uint8 id, address addr);\r\n    event NSEC3DigestUpdated(uint8 id, address addr);\r\n    event RRSetUpdated(bytes name, bytes rrset);\r\n\r\n    function submitRRSets(RRSetWithSignature[] memory input, bytes calldata proof) public virtual returns (bytes memory);\r\n    function submitRRSet(RRSetWithSignature calldata input, bytes calldata proof) public virtual returns (bytes memory);\r\n    function deleteRRSet(uint16 deleteType, bytes calldata deleteName, RRSetWithSignature calldata nsec, bytes calldata proof) public virtual;\r\n    function deleteRRSetNSEC3(uint16 deleteType, bytes memory deleteName, RRSetWithSignature memory closestEncloser, RRSetWithSignature memory nextClosest, bytes memory dnskey) public virtual;\r\n    function rrdata(uint16 dnstype, bytes calldata name) external virtual view returns (uint32, uint32, bytes20);\r\n}\r\n"
    },
    "contracts/registry/ENSRegistry.sol": {
      "content": "pragma solidity >=0.8.4;\r\n\r\nimport \"./ENS.sol\";\r\nimport \"../decentraname/IDecentraNameController.sol\";\r\n\r\n/**\r\n * The ENS registry contract.\r\n */\r\ncontract ENSRegistry is ENS {\r\n\r\n    struct Record {\r\n        address resolver;\r\n        uint64 ttl;\r\n    }\r\n\r\n    mapping (bytes32 => Record) records;\r\n    mapping (address => mapping(address => bool)) operators;\r\n\r\n    // The dweb NFT token\r\n    IDecentraNameController public decentraNameController;\r\n\r\n    // Permits modifications only by the owner of the specified node.\r\n    modifier authorised(bytes32 node) {\r\n        address owner = decentraNameController.ownerOf(uint256(node));\r\n        require(owner == msg.sender || operators[owner][msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructs a new ENS registrar.\r\n     */\r\n    constructor(IDecentraNameController _decentraNameController) public {\r\n        decentraNameController = _decentraNameController;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the record for a node.\r\n     * @param node The node to update.\r\n     * @param owner The address of the new owner.\r\n     * @param resolver The address of the resolver.\r\n     * @param ttl The TTL in seconds.\r\n     */\r\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual override {\r\n        setOwner(node, owner);\r\n        _setResolverAndTTL(node, resolver, ttl);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the record for a subnode.\r\n     * @param node The parent node.\r\n     * @param label The hash of the label specifying the subnode.\r\n     * @param owner The address of the new owner.\r\n     * @param resolver The address of the resolver.\r\n     * @param ttl The TTL in seconds.\r\n     */\r\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual override {\r\n        bytes32 subnode = setSubnodeOwner(node, label, owner);\r\n        _setResolverAndTTL(subnode, resolver, ttl);\r\n    }\r\n\r\n    /**\r\n     * @dev Create subdomain and sets the record for a subnode.\r\n     * @param node The parent node.\r\n     * @param label The hash of the label specifying the subnode.\r\n     * @param owner The address of the new owner.\r\n     * @param resolver The address of the resolver.\r\n     * @param ttl The TTL in seconds.\r\n     */\r\n    function createSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual override {\r\n        // TODO: revisit for modifier\r\n        bytes32 subnode = createSubnode(node, label, owner);\r\n        _setResolverAndTTL(subnode, resolver, ttl);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\r\n     * @param node The node to transfer ownership of.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function setOwner(bytes32 node, address owner) public virtual override authorised(node) {\r\n        // TODO: revisit authorized node because msg.sender won't be owner if called from other contracts\r\n        _setOwner(node, owner);\r\n        emit Transfer(node, owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Create a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\r\n     * @param node The parent node.\r\n     * @param label The hash of the label specifying the subnode.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function createSubnode(bytes32 node, bytes32 label, address owner) public virtual override authorised(node) returns(bytes32) {\r\n        // TODO: revisit authorized node because msg.sender won't be owner if called from other contracts\r\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\r\n        _createNode(subnode, owner);\r\n        emit NewOwner(node, label, owner);\r\n        return subnode;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\r\n     * @param node The parent node.\r\n     * @param label The hash of the label specifying the subnode.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public virtual override authorised(node) returns(bytes32) {\r\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\r\n        _setOwner(subnode, owner);\r\n        emit NewOwner(node, label, owner);\r\n        return subnode;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the resolver address for the specified node.\r\n     * @param node The node to update.\r\n     * @param resolver The address of the resolver.\r\n     */\r\n    function setResolver(bytes32 node, address resolver) public virtual override authorised(node) {\r\n        emit NewResolver(node, resolver);\r\n        records[node].resolver = resolver;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the TTL for the specified node.\r\n     * @param node The node to update.\r\n     * @param ttl The TTL in seconds.\r\n     */\r\n    function setTTL(bytes32 node, uint64 ttl) public virtual override authorised(node) {\r\n        emit NewTTL(node, ttl);\r\n        records[node].ttl = ttl;\r\n    }\r\n\r\n    /**\r\n     * @dev Enable or disable approval for a third party (\"operator\") to manage\r\n     *  all of `msg.sender`'s ENS records. Emits the ApprovalForAll event.\r\n     * @param operator Address to add to the set of authorized operators.\r\n     * @param approved True if the operator is approved, false to revoke approval.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external virtual override {\r\n        operators[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that owns the specified node.\r\n     * @param node The specified node.\r\n     * @return address of the owner.\r\n     */\r\n    function owner(bytes32 node) public virtual override view returns (address) {\r\n        address addr = decentraNameController.ownerOf(uint256(node));\r\n        // TODO: what is the impact of below after all code changes?\r\n        if (addr == address(this)) {\r\n            return address(0x0);\r\n        }\r\n\r\n        return addr;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the resolver for the specified node.\r\n     * @param node The specified node.\r\n     * @return address of the resolver.\r\n     */\r\n    function resolver(bytes32 node) public virtual override view returns (address) {\r\n        return records[node].resolver;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the TTL of a node, and any records associated with it.\r\n     * @param node The specified node.\r\n     * @return ttl of the node.\r\n     */\r\n    function ttl(bytes32 node) public virtual override view returns (uint64) {\r\n        return records[node].ttl;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether a record has been imported to the registry.\r\n     * @param node The specified node.\r\n     * @return Bool if record exists\r\n     */\r\n    function recordExists(bytes32 node) public virtual override view returns (bool) {\r\n        return decentraNameController.existsToken(uint256(node));\r\n    }\r\n\r\n    /**\r\n     * @dev Query if an address is an authorized operator for another address.\r\n     * @param owner The address that owns the records.\r\n     * @param operator The address that acts on behalf of the owner.\r\n     * @return True if `operator` is an approved operator for `owner`, false otherwise.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external virtual override view returns (bool) {\r\n        return operators[owner][operator];\r\n    }\r\n\r\n    function _setOwner(bytes32 node, address owner) internal virtual {\r\n        decentraNameController.transferToken(owner, uint256(node));\r\n    }\r\n\r\n    function _createNode(bytes32 node, address owner) internal virtual {\r\n        decentraNameController.mintToken(owner, uint256(node));\r\n    }\r\n\r\n    function _setResolverAndTTL(bytes32 node, address resolver, uint64 ttl) internal {\r\n        if(resolver != records[node].resolver) {\r\n            records[node].resolver = resolver;\r\n            emit NewResolver(node, resolver);\r\n        }\r\n\r\n        if(ttl != records[node].ttl) {\r\n            records[node].ttl = ttl;\r\n            emit NewTTL(node, ttl);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/dnsregistrar/DNSClaimChecker.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"../dnssec-oracle/DNSSEC.sol\";\r\nimport \"../dnssec-oracle/BytesUtils.sol\";\r\nimport \"../dnssec-oracle/RRUtils.sol\";\r\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\r\n\r\nlibrary DNSClaimChecker {\r\n\r\n    using BytesUtils for bytes;\r\n    using RRUtils for *;\r\n    using Buffer for Buffer.buffer;\r\n\r\n    uint16 constant CLASS_INET = 1;\r\n    uint16 constant TYPE_TXT = 16;\r\n\r\n    function getOwnerAddress(DNSSEC oracle, bytes memory name, bytes memory proof)\r\n        internal\r\n        view\r\n        returns (address, bool)\r\n    {\r\n        // Add \"_ens.\" to the front of the name.\r\n        Buffer.buffer memory buf;\r\n        buf.init(name.length + 5);\r\n        buf.append(\"\\x04_ens\");\r\n        buf.append(name);\r\n        bytes20 hash;\r\n        uint32 expiration;\r\n        // Check the provided TXT record has been validated by the oracle\r\n        (, expiration, hash) = oracle.rrdata(TYPE_TXT, buf.buf);\r\n        if (hash == bytes20(0) && proof.length == 0) return (address(0x0), false);\r\n\r\n        require(hash == bytes20(keccak256(proof)));\r\n\r\n        for (RRUtils.RRIterator memory iter = proof.iterateRRs(0); !iter.done(); iter.next()) {\r\n            require(RRUtils.serialNumberGte(expiration + iter.ttl, uint32(block.timestamp)), \"DNS record is stale; refresh or delete it before proceeding.\");\r\n\r\n            bool found;\r\n            address addr;\r\n            (addr, found) = parseRR(proof, iter.rdataOffset);\r\n            if (found) {\r\n                return (addr, true);\r\n            }\r\n        }\r\n\r\n        return (address(0x0), false);\r\n    }\r\n\r\n    function parseRR(bytes memory rdata, uint idx) internal pure returns (address, bool) {\r\n        while (idx < rdata.length) {\r\n            uint len = rdata.readUint8(idx); idx += 1;\r\n\r\n            bool found;\r\n            address addr;\r\n            (addr, found) = parseString(rdata, idx, len);\r\n\r\n            if (found) return (addr, true);\r\n            idx += len;\r\n        }\r\n\r\n        return (address(0x0), false);\r\n    }\r\n\r\n    function parseString(bytes memory str, uint idx, uint len) internal pure returns (address, bool) {\r\n        // TODO: More robust parsing that handles whitespace and multiple key/value pairs\r\n        if (str.readUint32(idx) != 0x613d3078) return (address(0x0), false); // 0x613d3078 == 'a=0x'\r\n        if (len < 44) return (address(0x0), false);\r\n        return hexToAddress(str, idx + 4);\r\n    }\r\n\r\n    function hexToAddress(bytes memory str, uint idx) internal pure returns (address, bool) {\r\n        if (str.length - idx < 40) return (address(0x0), false);\r\n        uint ret = 0;\r\n        for (uint i = idx; i < idx + 40; i++) {\r\n            ret <<= 4;\r\n            uint x = str.readUint8(i);\r\n            if (x >= 48 && x < 58) {\r\n                ret |= x - 48;\r\n            } else if (x >= 65 && x < 71) {\r\n                ret |= x - 55;\r\n            } else if (x >= 97 && x < 103) {\r\n                ret |= x - 87;\r\n            } else {\r\n                return (address(0x0), false);\r\n            }\r\n        }\r\n        return (address(uint160(ret)), true);\r\n    }\r\n}\r\n"
    },
    "contracts/dnsregistrar/PublicSuffixList.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\ninterface PublicSuffixList {\r\n    function isPublicSuffix(bytes calldata name) external view returns(bool);\r\n}\r\n"
    },
    "contracts/resolvers/profiles/AddrResolver.sol": {
      "content": "pragma solidity >=0.8.4;\r\nimport \"../ResolverBase.sol\";\r\n\r\nabstract contract AddrResolver is ResolverBase {\r\n    bytes4 constant private ADDR_INTERFACE_ID = 0x3b3b57de;\r\n    bytes4 constant private ADDRESS_INTERFACE_ID = 0xf1cb7e06;\r\n    uint constant private COIN_TYPE_ETH = 60;\r\n\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\r\n\r\n    mapping(bytes32=>mapping(uint=>bytes)) _addresses;\r\n\r\n    /**\r\n     * Sets the address associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param a The address to set.\r\n     */\r\n    function setAddr(bytes32 node, address a) external authorised(node) {\r\n        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));\r\n    }\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) public view returns (address payable) {\r\n        bytes memory a = addr(node, COIN_TYPE_ETH);\r\n        if(a.length == 0) {\r\n            return payable(0);\r\n        }\r\n        return bytesToAddress(a);\r\n    }\r\n\r\n    function setAddr(bytes32 node, uint coinType, bytes memory a) public authorised(node) {\r\n        emit AddressChanged(node, coinType, a);\r\n        if(coinType == COIN_TYPE_ETH) {\r\n            emit AddrChanged(node, bytesToAddress(a));\r\n        }\r\n        _addresses[node][coinType] = a;\r\n    }\r\n\r\n    function addr(bytes32 node, uint coinType) public view returns(bytes memory) {\r\n        return _addresses[node][coinType];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\r\n        return interfaceID == ADDR_INTERFACE_ID || interfaceID == ADDRESS_INTERFACE_ID || super.supportsInterface(interfaceID);\r\n    }\r\n\r\n    function bytesToAddress(bytes memory b) internal pure returns(address payable a) {\r\n        require(b.length == 20);\r\n        assembly {\r\n            a := div(mload(add(b, 32)), exp(256, 12))\r\n        }\r\n    }\r\n\r\n    function addressToBytes(address a) internal pure returns(bytes memory b) {\r\n        b = new bytes(20);\r\n        assembly {\r\n            mstore(add(b, 32), mul(a, exp(256, 12)))\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/RRUtils.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"./BytesUtils.sol\";\r\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\r\n\r\n/**\r\n* @dev RRUtils is a library that provides utilities for parsing DNS resource records.\r\n*/\r\nlibrary RRUtils {\r\n    using BytesUtils for *;\r\n    using Buffer for *;\r\n\r\n    /**\r\n    * @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\r\n    * @param self The byte array to read a name from.\r\n    * @param offset The offset to start reading at.\r\n    * @return The length of the DNS name at 'offset', in bytes.\r\n    */\r\n    function nameLength(bytes memory self, uint offset) internal pure returns(uint) {\r\n        uint idx = offset;\r\n        while (true) {\r\n            assert(idx < self.length);\r\n            uint labelLen = self.readUint8(idx);\r\n            idx += labelLen + 1;\r\n            if (labelLen == 0) {\r\n                break;\r\n            }\r\n        }\r\n        return idx - offset;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns a DNS format name at the specified offset of self.\r\n    * @param self The byte array to read a name from.\r\n    * @param offset The offset to start reading at.\r\n    * @return ret The name.\r\n    */\r\n    function readName(bytes memory self, uint offset) internal pure returns(bytes memory ret) {\r\n        uint len = nameLength(self, offset);\r\n        return self.substring(offset, len);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\r\n    * @param self The byte array to read a name from.\r\n    * @param offset The offset to start reading at.\r\n    * @return The number of labels in the DNS name at 'offset', in bytes.\r\n    */\r\n    function labelCount(bytes memory self, uint offset) internal pure returns(uint) {\r\n        uint count = 0;\r\n        while (true) {\r\n            assert(offset < self.length);\r\n            uint labelLen = self.readUint8(offset);\r\n            offset += labelLen + 1;\r\n            if (labelLen == 0) {\r\n                break;\r\n            }\r\n            count += 1;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    uint constant RRSIG_TYPE = 0;\r\n    uint constant RRSIG_ALGORITHM = 2;\r\n    uint constant RRSIG_LABELS = 3;\r\n    uint constant RRSIG_TTL = 4;\r\n    uint constant RRSIG_EXPIRATION = 8;\r\n    uint constant RRSIG_INCEPTION = 12;\r\n    uint constant RRSIG_KEY_TAG = 16;\r\n    uint constant RRSIG_SIGNER_NAME = 18;\r\n\r\n    struct SignedSet {\r\n        uint16 typeCovered;\r\n        uint8 algorithm;\r\n        uint8 labels;\r\n        uint32 ttl;\r\n        uint32 expiration;\r\n        uint32 inception;\r\n        uint16 keytag;\r\n        bytes signerName;\r\n        bytes data;\r\n        bytes name;\r\n    }\r\n\r\n    function readSignedSet(bytes memory data) internal pure returns(SignedSet memory self) {\r\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\r\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\r\n        self.labels = data.readUint8(RRSIG_LABELS);\r\n        self.ttl = data.readUint32(RRSIG_TTL);\r\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\r\n        self.inception = data.readUint32(RRSIG_INCEPTION);\r\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\r\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\r\n        self.data = data.substring(RRSIG_SIGNER_NAME + self.signerName.length, data.length - RRSIG_SIGNER_NAME - self.signerName.length);\r\n    }\r\n\r\n    function rrs(SignedSet memory rrset) internal pure returns(RRIterator memory) {\r\n        return iterateRRs(rrset.data, 0);\r\n    }\r\n\r\n    /**\r\n    * @dev An iterator over resource records.\r\n    */\r\n    struct RRIterator {\r\n        bytes data;\r\n        uint offset;\r\n        uint16 dnstype;\r\n        uint16 class;\r\n        uint32 ttl;\r\n        uint rdataOffset;\r\n        uint nextOffset;\r\n    }\r\n\r\n    /**\r\n    * @dev Begins iterating over resource records.\r\n    * @param self The byte string to read from.\r\n    * @param offset The offset to start reading at.\r\n    * @return ret An iterator object.\r\n    */\r\n    function iterateRRs(bytes memory self, uint offset) internal pure returns (RRIterator memory ret) {\r\n        ret.data = self;\r\n        ret.nextOffset = offset;\r\n        next(ret);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns true iff there are more RRs to iterate.\r\n    * @param iter The iterator to check.\r\n    * @return True iff the iterator has finished.\r\n    */\r\n    function done(RRIterator memory iter) internal pure returns(bool) {\r\n        return iter.offset >= iter.data.length;\r\n    }\r\n\r\n    /**\r\n    * @dev Moves the iterator to the next resource record.\r\n    * @param iter The iterator to advance.\r\n    */\r\n    function next(RRIterator memory iter) internal pure {\r\n        iter.offset = iter.nextOffset;\r\n        if (iter.offset >= iter.data.length) {\r\n            return;\r\n        }\r\n\r\n        // Skip the name\r\n        uint off = iter.offset + nameLength(iter.data, iter.offset);\r\n\r\n        // Read type, class, and ttl\r\n        iter.dnstype = iter.data.readUint16(off);\r\n        off += 2;\r\n        iter.class = iter.data.readUint16(off);\r\n        off += 2;\r\n        iter.ttl = iter.data.readUint32(off);\r\n        off += 4;\r\n\r\n        // Read the rdata\r\n        uint rdataLength = iter.data.readUint16(off);\r\n        off += 2;\r\n        iter.rdataOffset = off;\r\n        iter.nextOffset = off + rdataLength;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the name of the current record.\r\n    * @param iter The iterator.\r\n    * @return A new bytes object containing the owner name from the RR.\r\n    */\r\n    function name(RRIterator memory iter) internal pure returns(bytes memory) {\r\n        return iter.data.substring(iter.offset, nameLength(iter.data, iter.offset));\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the rdata portion of the current record.\r\n    * @param iter The iterator.\r\n    * @return A new bytes object containing the RR's RDATA.\r\n    */\r\n    function rdata(RRIterator memory iter) internal pure returns(bytes memory) {\r\n        return iter.data.substring(iter.rdataOffset, iter.nextOffset - iter.rdataOffset);\r\n    }\r\n\r\n    uint constant DNSKEY_FLAGS = 0;\r\n    uint constant DNSKEY_PROTOCOL = 2;\r\n    uint constant DNSKEY_ALGORITHM = 3;\r\n    uint constant DNSKEY_PUBKEY = 4;\r\n\r\n    struct DNSKEY {\r\n        uint16 flags;\r\n        uint8 protocol;\r\n        uint8 algorithm;\r\n        bytes publicKey;\r\n    }\r\n\r\n    function readDNSKEY(bytes memory data, uint offset, uint length) internal pure returns(DNSKEY memory self) {\r\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\r\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\r\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\r\n        self.publicKey = data.substring(offset + DNSKEY_PUBKEY, length - DNSKEY_PUBKEY);\r\n    } \r\n\r\n    uint constant DS_KEY_TAG = 0;\r\n    uint constant DS_ALGORITHM = 2;\r\n    uint constant DS_DIGEST_TYPE = 3;\r\n    uint constant DS_DIGEST = 4;\r\n\r\n    struct DS {\r\n        uint16 keytag;\r\n        uint8 algorithm;\r\n        uint8 digestType;\r\n        bytes digest;\r\n    }\r\n\r\n    function readDS(bytes memory data, uint offset, uint length) internal pure returns(DS memory self) {\r\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\r\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\r\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\r\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\r\n    }\r\n\r\n    struct NSEC3 {\r\n        uint8 hashAlgorithm;\r\n        uint8 flags;\r\n        uint16 iterations;\r\n        bytes salt;\r\n        bytes32 nextHashedOwnerName;\r\n        bytes typeBitmap;\r\n    }\r\n\r\n    uint constant NSEC3_HASH_ALGORITHM = 0;\r\n    uint constant NSEC3_FLAGS = 1;\r\n    uint constant NSEC3_ITERATIONS = 2;\r\n    uint constant NSEC3_SALT_LENGTH = 4;\r\n    uint constant NSEC3_SALT = 5;\r\n\r\n    function readNSEC3(bytes memory data, uint offset, uint length) internal pure returns(NSEC3 memory self) {\r\n        uint end = offset + length;\r\n        self.hashAlgorithm = data.readUint8(offset + NSEC3_HASH_ALGORITHM);\r\n        self.flags = data.readUint8(offset + NSEC3_FLAGS);\r\n        self.iterations = data.readUint16(offset + NSEC3_ITERATIONS);\r\n        uint8 saltLength = data.readUint8(offset + NSEC3_SALT_LENGTH);\r\n        offset = offset + NSEC3_SALT;\r\n        self.salt = data.substring(offset, saltLength);\r\n        offset += saltLength;\r\n        uint8 nextLength = data.readUint8(offset);\r\n        require(nextLength <= 32);\r\n        offset += 1;\r\n        self.nextHashedOwnerName = data.readBytesN(offset, nextLength);\r\n        offset += nextLength;\r\n        self.typeBitmap = data.substring(offset, end - offset);\r\n    }\r\n\r\n    function checkTypeBitmap(NSEC3 memory self, uint16 rrtype) internal pure returns(bool) {\r\n        return checkTypeBitmap(self.typeBitmap, 0, rrtype);\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if a given RR type exists in a type bitmap.\r\n    * @param bitmap The byte string to read the type bitmap from.\r\n    * @param offset The offset to start reading at.\r\n    * @param rrtype The RR type to check for.\r\n    * @return True if the type is found in the bitmap, false otherwise.\r\n    */\r\n    function checkTypeBitmap(bytes memory bitmap, uint offset, uint16 rrtype) internal pure returns (bool) {\r\n        uint8 typeWindow = uint8(rrtype >> 8);\r\n        uint8 windowByte = uint8((rrtype & 0xff) / 8);\r\n        uint8 windowBitmask = uint8(uint8(1) << (uint8(7) - uint8(rrtype & 0x7)));\r\n        for (uint off = offset; off < bitmap.length;) {\r\n            uint8 window = bitmap.readUint8(off);\r\n            uint8 len = bitmap.readUint8(off + 1);\r\n            if (typeWindow < window) {\r\n                // We've gone past our window; it's not here.\r\n                return false;\r\n            } else if (typeWindow == window) {\r\n                // Check this type bitmap\r\n                if (len <= windowByte) {\r\n                    // Our type is past the end of the bitmap\r\n                    return false;\r\n                }\r\n                return (bitmap.readUint8(off + windowByte + 2) & windowBitmask) != 0;\r\n            } else {\r\n                // Skip this type bitmap\r\n                off += len + 2;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function compareNames(bytes memory self, bytes memory other) internal pure returns (int) {\r\n        if (self.equals(other)) {\r\n            return 0;\r\n        }\r\n\r\n        uint off;\r\n        uint otheroff;\r\n        uint prevoff;\r\n        uint otherprevoff;\r\n        uint counts = labelCount(self, 0);\r\n        uint othercounts = labelCount(other, 0);\r\n\r\n        // Keep removing labels from the front of the name until both names are equal length\r\n        while (counts > othercounts) {\r\n            prevoff = off;\r\n            off = progress(self, off);\r\n            counts--;\r\n        }\r\n\r\n        while (othercounts > counts) {\r\n            otherprevoff = otheroff;\r\n            otheroff = progress(other, otheroff);\r\n            othercounts--;\r\n        }\r\n\r\n        // Compare the last nonequal labels to each other\r\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\r\n            prevoff = off;\r\n            off = progress(self, off);\r\n            otherprevoff = otheroff;\r\n            otheroff = progress(other, otheroff);\r\n            counts -= 1;\r\n        }\r\n\r\n        if (off == 0) {\r\n            return -1;\r\n        }\r\n        if(otheroff == 0) {\r\n            return 1;\r\n        }\r\n\r\n        return self.compare(prevoff + 1, self.readUint8(prevoff), other, otherprevoff + 1, other.readUint8(otherprevoff));\r\n    }\r\n\r\n    /**\r\n     * @dev Compares two serial numbers using RFC1982 serial number math.\r\n     */\r\n    function serialNumberGte(uint32 i1, uint32 i2) internal pure returns(bool) {\r\n        return int32(i1) - int32(i2) >= 0;\r\n    }\r\n\r\n    function progress(bytes memory body, uint off) internal pure returns(uint) {\r\n        return off + 1 + body.readUint8(off);\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the keytag for a chunk of data.\r\n     * @param data The data to compute a keytag for.\r\n     * @return The computed key tag.\r\n     */\r\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\r\n        /* This function probably deserves some explanation.\r\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\r\n         * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\r\n         *\r\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\r\n         *         uint ac;\r\n         *         for (uint i = 0; i < data.length; i++) {\r\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\r\n         *         }\r\n         *         return uint16(ac + (ac >> 16));\r\n         *     }\r\n         *\r\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\r\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM's\r\n         * large words work in our favour.\r\n         *\r\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\r\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\r\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we're\r\n         * effectively summing 16 different numbers with each EVM ADD opcode.\r\n         *\r\n         * Once it's added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\r\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\r\n         * After the first addition on both accumulators, there's enough room to add the two accumulators together,\r\n         * and the remaining sums can be done just on ac1.\r\n         */\r\n        unchecked {\r\n            require(data.length <= 8192, \"Long keys not permitted\");\r\n            uint ac1;\r\n            uint ac2;\r\n            for(uint i = 0; i < data.length + 31; i += 32) {\r\n                uint word;\r\n                assembly {\r\n                    word := mload(add(add(data, 32), i))\r\n                }\r\n                if(i + 32 > data.length) {\r\n                    uint unused = 256 - (data.length - i) * 8;\r\n                    word = (word >> unused) << unused;\r\n                }\r\n                ac1 += (word & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8;\r\n                ac2 += (word & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\r\n            }\r\n            ac1 = (ac1 & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\r\n                + ((ac1 & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16);\r\n            ac2 = (ac2 & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF)\r\n                + ((ac2 & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16);\r\n            ac1 = (ac1 << 8) + ac2;\r\n            ac1 = (ac1 & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF)\r\n                + ((ac1 & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32);\r\n            ac1 = (ac1 & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF)\r\n                + ((ac1 & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64);\r\n            ac1 = (ac1 & 0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                + (ac1 >> 128);\r\n            ac1 += (ac1 >> 16) & 0xFFFF;\r\n            return uint16(ac1);\r\n        }\r\n    }\r\n}"
    },
    "@ensdomains/buffer/contracts/Buffer.sol": {
      "content": "pragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for writing to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(32, add(ptr, capacity)))\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint a, uint b) private pure returns(uint) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The start offset to write to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, len);\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, data.length);\n    }\n\n    /**\n    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The offset to write the byte at.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\n        if (off >= buf.capacity) {\n            resize(buf, buf.capacity * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if eq(off, buflen) {\n                mstore(bufptr, add(buflen, 1))\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        return writeUint8(buf, buf.buf.length, data);\n    }\n\n    /**\n    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The offset to write at.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + off + len\n                let dest := add(add(bufptr, off), len)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(add(off, len), mload(bufptr)) {\n                    mstore(bufptr, add(off, len))\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The offset to write at.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\n        return write(buf, off, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, 32);\n    }\n\n    /**\n    * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The offset to write at.\n    * @param data The data to append.\n    * @param len The number of bytes to write (right-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + off + sizeof(buffer length) + len\n            let dest := add(add(bufptr, off), len)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(add(off, len), mload(bufptr)) {\n                mstore(bufptr, add(off, len))\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     * exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        return writeInt(buf, buf.buf.length, data, len);\n    }\n}\n"
    },
    "contracts/resolvers/ResolverBase.sol": {
      "content": "pragma solidity >=0.8.4;\r\nabstract contract ResolverBase {\r\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\r\n\r\n    function supportsInterface(bytes4 interfaceID) virtual public pure returns(bool) {\r\n        return interfaceID == INTERFACE_META_ID;\r\n    }\r\n\r\n    function isAuthorised(bytes32 node) internal virtual view returns(bool);\r\n\r\n    modifier authorised(bytes32 node) {\r\n        require(isAuthorised(node));\r\n        _;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}